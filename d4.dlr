%{
	BasicType2 := lbrack AssignExpression rbrack;
	DeclaratorSuffix := lbrack AssignExpression rback;
}%

%{
	Declarator := identifier;
	TemplateTypeParameter := identifier;
}%

%left andShiftExpr
%right abstract auto const deprecated extern final immutable inout shared nothrow override pure ref scope static synchronized gshared thread
%right dot

S := Module;

Module :=
	ModuleDeclaration;
	| ModuleDeclaration DeclDefs; 
		{: ret = buildTreeWithLoc(termModule, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| DeclDefs;

ModuleDeclaration :=
	module ModuleFullyQualifiedName semicolon; 
		{: ret = buildTreeWithLoc(termModuleDeclaration, [-2], actionNum,
		this.tokenStack[-3].getLoc()); :}

ModuleFullyQualifiedName :=
	ModuleName;
	| Packages dot ModuleName; 
		{: ret = buildTreeWithLoc(termModuleDeclaration, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

ModuleName :=
	identifier;

Packages :=
	PackageName;
	| Packages dot PackageName; 
		{: ret = buildTreeWithLoc(termPackages, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

PackageName :=
	identifier;

DeclDefs :=
	DeclDef;
	| DeclDefs DeclDef; 
		{: ret = buildTreeWithLoc(termDeclDefs, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

DeclDef :=
	AttributeSpecifier;
	| ImportDeclaration;
	| EnumDeclaration;
	| ClassDeclaration;
	| InterfaceDeclaration;
	| AggregateDeclaration;
	| Declaration;
	| Constructor;
	| Destructor;
	| UnitTest;
	| StaticConstructor;
	| StaticDestructor;
	| SharedStaticConstructor;
	| SharedStaticDestructor;
	| ConditionalDeclaration;
	| DebugSpecification;
	| VersionSpecification;
	| StaticAssert;
	| TemplateDeclaration;
	| TemplateMixinDeclaration;
	| TemplateMixin;
	| MixinDeclaration;
	| semicolon;

ImportDeclaration :=
	import ImportList semicolon; 
		{: ret = buildTreeWithLoc(termImportDeclaration, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}

	| static import ImportList semicolon; 
		{: ret = buildTreeWithLoc(termImportDeclaration, [-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}

ImportList :=
	Import; 
	| ImportBindings; 
	| ImportList comma Import; 
		{: ret = buildTreeWithLoc(termImportList, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

Import :=
	IdentifierList; 
	| ModuleAliasIdentifier assign IdentifierList; 
		{: ret = buildTreeWithLoc(termImport, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

ImportBindings :=
	Import colon ImportBindList; 
		{: ret = buildTreeWithLoc(termImportBindings, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

ImportBindList :=
	ImportBind;
	| ImportBindList comma ImportBind; 
		{: ret = buildTreeWithLoc(termImportBindList, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

ImportBind :=
	identifier;
	| identifier assign identifier; 
		{: ret = buildTreeWithLoc(termImportBind, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

ModuleAliasIdentifier :=
	identifier;

MixinDeclaration :=
	mixin lparen AssignExpression rparen semicolon; 
		{: ret = buildTreeWithLoc(termMixinDeclaration, [-3], actionNum,
			this.tokenStack[-5].getLoc()); :}

Declaration :=
	AliasDeclaration;
	| AliasThisDeclaration;
	| Decl;

AliasDeclaration :=
	alias BasicType Declarator; 
		{: ret = buildTreeWithLoc(termAliasDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	
AliasThisDeclaration := 
	alias identifier this;
		{: ret = buildTreeWithLoc(termAliasThisDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

Decl := StorageClasses Decl; 
		{: ret = buildTreeWithLoc(termDecl, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType Declarators semicolon; 
		{: ret = buildTreeWithLoc(termDecl, [-3,-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType Declarator FunctionBody; 
		{: ret = buildTreeWithLoc(termDecl, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| AutoDeclaration;

Declarators :=
	DeclaratorInitializer;
	| DeclaratorIdentifierList comma DeclaratorIdentifier; 
		{: ret = buildTreeWithLoc(termDeclarators, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

DeclaratorInitializer :=
	Declarator;
	| Declarator assgin Initializer;
		{: ret = buildTreeWithLoc(termDeclaratorInitializer, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

DeclaratorIdentifierList :=
	DeclaratorIdentifier;
	| DeclaratorIdentifierList comma DeclaratorIdentifier;
		{: ret = buildTreeWithLoc(termDeclaratorIdentifierList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

DeclaratorIdentifier :=
	identifier;
	| identifier assgin Initializer;
		{: ret = buildTreeWithLoc(termDeclaratorIdentifier, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

AutoDeclaration := 
	StorageClasses AutoDeclarationX semicolon; 
		{: ret = buildTreeWithLoc(termAutoDeclaration, [-3,-2], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	
AutoDeclarationX := identifier assign Initializer;
		{: ret = buildTreeWithLoc(termAutoDeclarationX, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| AutoDeclarationX comma identifier assign Initializer;
		{: ret = buildTreeWithLoc(termAutoDeclarationX, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

BasicType :=
	BasicTypeX;
	| dot IdentifierList; 
		{: ret = buildTreeWithLoc(termBasicType, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| IdentifierList;
	| Typeof;
	| Typeof dot IdentifierList;
		{: ret = buildTreeWithLoc(termBasicType, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| const lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| immutable lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| shared lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| inout lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}

BasicTypeX :=
	bool;
	| byte;
	| ubyte;
	| short;
	| ushort;
	| int;
	| uint;
	| long;
	| ulong;
	| char;
	| wchar;
	| dchar;
	| float;
	| double;
	| real;
	| ifloat;
	| idouble;
	| ireal;
	| cfloat;
	| cdouble;
	| creal;
	| void;

BasicType2 :=
	star;
	| lbrack rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lbrack AssignExpression rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-1], actionNum, 
			this.tokenStack[-1].getLoc()); :}
	| lbrack AssignExpression dotdot AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termBasicType2, [-4,-3,-2], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| lbrack Type rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| delegate Parameters FunctionAttributes;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| function Parameters FunctionAttributes;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| delegate Parameters;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| function Parameters;
		{: ret = buildTreeWithLoc(termBasicType2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

BasicTypes2 :=
	BasicType2;
	| BasicTypes2 BasicType2;
		{: ret = buildTreeWithLoc(termBasicTypes2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

Declarator :=
	BasicType2 identifier;
		{: ret = buildTreeWithLoc(termDeclarator, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType2 identifier DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType2 lparen Declarator rparen;
		{: ret = buildTreeWithLoc(termDeclarator, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| BasicType2 lparen Declarator rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-5,-3,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| identifier ;
	| identifier DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lparen Declarator rparen;
		{: ret = buildTreeWithLoc(termDeclarator, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lparen Declarator rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

DeclaratorSuffixes :=
	DeclaratorSuffix;
	| DeclaratorSuffixes DeclaratorSuffix;
		{: ret = buildTreeWithLoc(termDeclaratorSuffixes, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

DeclaratorSuffix :=
	lbrack rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lbrack AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lbrack Type rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| Parameters;
	| Parameters Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| Parameters MemberFunctionAttributes Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| Parameters MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| TemplateParameterList Parameters Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters MemberFunctionAttributes Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

IdentifierList :=
	identifier ;
	| IdentifierList dot identifier; 
		{: ret = buildTreeWithLoc(termIdentifierList, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| TemplateInstance ;
	| TemplateInstance dot IdentifierList; 
		{: ret = buildTreeWithLoc(termTemplateInstance, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

StorageClasses :=
	StorageClass;
	| StorageClasses StorageClass;
		{: ret = buildTreeWithLoc(termStorageClasses, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

StorageClass :=
	abstract;
	| auto;
	| const;
	| deprecated;
	| extern;
	| final;
	| immutable;
	| inout;
	| shared;
	| nothrow;
	| override;
	| pure;
	| ref;
	| scope;
	| static;
	| synchronized;
	| gshared;
	| thread;

Property :=
	disable;
	| safe;
	| system;
	| trusted;
	| property;

Type :=
	BasicType;
	| BasicType Declarator2;
		{: ret = buildTreeWithLoc(termType, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

Declarator2 :=
	BasicType2 DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType2;
	| DeclaratorSuffixes;
	| BasicType2 lparen Declarator2 rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-5,-3,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| lparen Declarator2 rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| BasicType2 lparen Declarator2 rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| lparen Declarator2 rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}

Parameters :=
	lparen ParameterList rparen;
		{: ret = buildTreeWithLoc(termParameters, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lparen rparen;
		{: ret = buildTreeWithLoc(termParameters, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

ParameterList :=
	Parameter;
	| ParameterList comma Parameter;
		{: ret = buildTreeWithLoc(termParameterList, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| dotdotdot;

Parameter :=
	InOut BasicType Declarator;
		{: ret = buildTreeWithLoc(termParameter, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| InOut BasicType Declarator dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| InOut BasicType Declarator assign DefaultInitializerExpression;
		{: ret = buildTreeWithLoc(termParameter, [-5,-4,-3,-2,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| InOut Type InOut Type dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| BasicType Declarator ;
		{: ret = buildTreeWithLoc(termParameter, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType Declarator dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType Declarator assign DefaultInitializerExpression;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| Type InOut Type dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

InOut :=
	InOutX;
	| InOut InOutX;
		{: ret = buildTreeWithLoc(termInOut, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

InOutX :=
	in;
	| out;
	| ref;
	| lazy;
	| scope;

FunctionAttributes :=
	FunctionAttribute;
	| FunctionAttribute FunctionAttributes;
		{: ret = buildTreeWithLoc(termFunctionAttributes, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

FunctionAttribute :=
	nothrow;
	| pure;
	| Property;

MemberFunctionAttributes :=
	MemberFunctionAttribute;
	| MemberFunctionAttribute MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termMemberFunctionAttributes, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

MemberFunctionAttribute :=
	const;
	| immutable;
	| inout;
	| shared;
	| FunctionAttribute;

DefaultInitializerExpression := assign AssignExpression;
		{: ret = buildTreeWithLoc(termDefaultInitializerExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| file;
	| line;

Initializer :=
	VoidInitializer;
	| NonVoidInitializer;

NonVoidInitializer :=
	AssignExpression;
	| ArrayInitializer;
	| StructInitializer;

ArrayInitializer :=
	lbrack rbrack;
		{: ret = buildTreeWithLoc(termArrayInitializer, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| lbrack ArrayMemberInitializations rbrack;
		{: ret = buildTreeWithLoc(termArrayInitializer, [-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

ArrayMemberInitializations :=
	ArrayMemberInitialization;
	| ArrayMemberInitialization comma;
		{: ret = buildTreeWithLoc(termArrayMemberInitializations, [-2], 
			actionNum, this.tokenStack[-1].getLoc()); :}
	| ArrayMemberInitialization comma ArrayMemberInitializations;
		{: ret = buildTreeWithLoc(termArrayMemberInitializations, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

ArrayMemberInitialization :=
	NonVoidInitializer;
	| AssignExpression colon NonVoidInitializer;
		{: ret = buildTreeWithLoc(termArrayMemberInitialization, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

StructInitializer :=
	lcurly rcurly;
	| lcurly StructMemberInitializers rcurly;
		{: ret = buildTreeWithLoc(termStructInitializer, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

StructMemberInitializers :=
	StructMemberInitializer;
	| StructMemberInitializer comma;
		{: ret = buildTreeWithLoc(termStructMemberInitializers, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| StructMemberInitializer comma StructMemberInitializers;
		{: ret = buildTreeWithLoc(termStructMemberInitializers, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

StructMemberInitializer :=
	NonVoidInitializer;
	| identifier colon NonVoidInitializer;
		{: ret = buildTreeWithLoc(termStructMemberInitializer, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

Typeof :=
	typeof lparen Expression rparen;
		{: ret = buildTreeWithLoc(termTypeof, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| typeof lparen return rparen;
		{: ret = buildTreeWithLoc(termTypeof, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

VoidInitializer :=
	void;

AttributeSpecifier :=
	Attribute colon;
	| Attribute DeclarationBlock;
		{: ret = buildTreeWithLoc(termAttributeSpecifier, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

Attribute :=
	AlignAttribute;
	| LinkageAttribute;
	| Pragma;
	| ProtectionAttribute;
	| gshared;
	| thread;
	| abstract;
	| auto;
	| const;
	| deprecated;
	| disable;
	| extern;
	| final;
	| immutable;
	| inout;
	| override;
	| property;
	| ref;
	| safe;
	| scope;
	| shared;
	| static;
	| synchronized;
	| system;
	| trusted;

DeclarationBlock :=
	DeclDef;
	| lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termDeclarationBlock, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lcurly rcurly;
		{: ret = buildTreeWithLoc(termDeclarationBlock, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

LinkageAttribute :=
	extern lparen identifier rparen;
		{: ret = buildTreeWithLoc(termLinkageAttribute, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

AlignAttribute :=
	align;
	| align lparen integer rparen;
		{: ret = buildTreeWithLoc(termAlignAttribute, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

ProtectionAttribute :=
	export;
	| package;
	| private;
	| protected;
	| public;

Pragma :=
	pragma lparen identifier rparen;
		{: ret = buildTreeWithLoc(termPragma, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| pragma lparen identifier comma ArgumentList rparen;
		{: ret = buildTreeWithLoc(termPragma, [-4,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}

Expression :=
	CommaExpression;

CommaExpression :=
	AssignExpression;
	| AssignExpression comma CommaExpression;
		{: ret = buildTreeWithLoc(termCommaExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression plusassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression minusassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression starassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression divassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression moduloassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression andassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression orassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression xorassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression tildeassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression leftshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression rightshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression xorxorassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = buildTreeWithLoc(termConditionalExpression, [-5,-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicalor AndAndExpression;
		{: ret = buildTreeWithLoc(termOrOrExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

AndAndExpression :=
	OrExpression;
	| AndAndExpression logicaland OrExpression;
		{: ret = buildTreeWithLoc(termAndAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| CmpExpression;
	| AndAndExpression logicaland CmpExpression;
		{: ret = buildTreeWithLoc(termAndAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

OrExpression :=
	XorExpression;
	| OrExpression or XorExpression;
		{: ret = buildTreeWithLoc(termOrExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression;
		{: ret = buildTreeWithLoc(termXorExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

AndExpression :=
	ShiftExpression ;
	| AndExpression and ShiftExpression;
		{: ret = buildTreeWithLoc(termAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

CmpExpression :=
	ShiftExpression;
	| EqualExpression;
	| IdentityExpression;
	| RelExpression;
	| InExpression;

EqualExpression :=
	ShiftExpression equal ShiftExpression;
		{: ret = buildTreeWithLoc(termEqualExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression notequal ShiftExpression;
		{: ret = buildTreeWithLoc(termEqualExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

IdentityExpression :=
	ShiftExpression is ShiftExpression;
		{: ret = buildTreeWithLoc(termIdentityExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangis ShiftExpression;
		{: ret = buildTreeWithLoc(termIdentityExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

RelExpression :=
	ShiftExpression less ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression lessequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression greater ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression greaterequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangsquareassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangsquare ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression square ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression squareassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banggreater ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banggreaterassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangless ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banglessequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

InExpression :=
	ShiftExpression in ShiftExpression;
		{: ret = buildTreeWithLoc(termInExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangin ShiftExpression;
		{: ret = buildTreeWithLoc(termInExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression rightshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression unsignedrightshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

AddExpression :=
	MulExpression;
	| CatExpression;
	| AddExpression plus MulExpression;
		{: ret = buildTreeWithLoc(termAddExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| AddExpression minus MulExpression;
		{: ret = buildTreeWithLoc(termAddExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

CatExpression :=
	AddExpression tilde MulExpression;
		{: ret = buildTreeWithLoc(termCatExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

MulExpression :=
	PowExpression;
	| MulExpression star PowExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| MulExpression div PowExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| MulExpression modulo PowExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

PowExpression :=
	PostfixExpression;
	| PostfixExpression xorxor UnaryExpression;
		{: ret = buildTreeWithLoc(termPowExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

UnaryExpression :=
	and UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| increment UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| decrement UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| star UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| minus UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| plus UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| bang UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ComplementExpression;
	| lparen Type rparen dot identifier;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-4,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| NewExpression;
	| DeleteExpression;
	| CastExpression;
	| PowExpression;

ComplementExpression := tilde UnaryExpression;
		{: ret = buildTreeWithLoc(termComplementExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

NewExpression := new AllocatorArguments Type lbrack AssignExpression rbrack;
	| new Type lbrack AssignExpression rbrack;
	| new AllocatorArguments Type lparen ArgumentList lparen;
	| new Type lparen ArgumentList lparen;
	| new AllocatorArguments Type;
	| new Type;
	| NewAnonClassExpression;

AllocatorArguments :=
	lparen ArgumentList rparen;
	| lparen rparen;

ArgumentList :=
	AssignExpression ;
	| AssignExpression comma;
	| AssignExpression comma ArgumentList;

ClassArguments :=
	class lparen ArgumentList rparen;
	| class lparen rparen;
	| class;

DeleteExpression :=
	delete UnaryExpression;

CastExpression :=
	cast lparen Type rparen UnaryExpression;
	| cast lapren CastQual rparen UnaryExpression;
	| cast lparen rparen UnaryExpression;

CastQual :=
	const;
	| const shared;
	| shared const;
	| inout;
	| inout shared;
	| shared inout;
	| immutable;
	| shared;

PostfixExpression :=
	PrimaryExpression;
	| PostfixExpression dot IdentifierOrTemplateInstance;
	| PostfixExpression dot NewExpression;
	| PostfixExpression plusplus;
	| PostfixExpression minusminus;
	| PostfixExpression lparen rparen;
	| PostfixExpression lparen ArgumentList rparen;
	| IndexExpression;
	| SliceExpression;

IndexExpression :=
	PostfixExpression lbrack ArgumentList rbrack;

SliceExpression :=
	PostfixExpression lbrack rbrack;
	| PostfixExpression lbrack AssignExpression dotdot AssignExpression rbrack;

PrimaryExpression :=
	identifier;
	| dot identifier;
	| TemplateInstance;
	| dot TemplateInstance;
	| this;
	| super;
	| null;
	| true;
	| false;
	| dollarsym;
	| file;
	| line;
	| integer;
	| floatliteral;
	| charliteral;
	| stringliteral;
	| ArrayLiteral;
	| AssocArrayLiteral;
	| Lambda;
	| FunctionLiteral;
	| AssertExpression;
	| MixinExpression;
	| ImportExpression;
	| BasicType dot identifier;
	| Typeof;
	| TypeidExpression;
	| IsExpression;
	| lparen Expression rparen;
	| TraitsExpression;

Lambda :=
	identifier arrow AssignExpression;
	| ParameterAttributes arrow AssignExpression;

ArrayLiteral :=
	lbrack ArgumentList rbrack;

AssocArrayLiteral :=
	lbrack KeyValuePairs rbrack;

KeyValuePairs :=
	KeyValuePair;
	| KeyValuePair comma KeyValuePairs;

KeyValuePair :=
	KeyExpression colon ValueExpression;

KeyExpression :=
	AssignExpression;

ValueExpression :=
	AssignExpression;

FunctionLiteral :=
	function Type ParameterAttributes FunctionBody;
	| function ParameterAttributes FunctionBody;
	| function Type FunctionBody;
	| function FunctionBody;
	| delegate Type ParameterAttributes FunctionBody;
	| delegate ParameterAttributes FunctionBody;
	| delegate Type FunctionBody;
	| delegate FunctionBody;
	| ParameterAttributes FunctionBody;
	| FunctionBody;

ParameterAttributes :=
	Parameters;
	| Parameters FunctionAttributes;

AssertExpression :=
	assert lparen AssignExpression rparen;
	| assert lparen AssignExpression comma AssignExpression rparen;

MixinExpression :=
	mixin lparen AssignExpression rparen;

ImportExpression :=
	import lparen AssignExpression rparen;

TypeidExpression :=
	typeid lparen Type rparen;
	| typeid lparen Expression rparen;

IsExpression :=
	is lparen Type rparen;
	| is lparen Type colon TypeSpecialization rparen;
	| is lparen Type equal TypeSpecialization rparen;
	| is lparen Type identifier rparen;
	| is lparen Type identifier colon TypeSpecialization rparen;
	| is lparen Type identifier equal TypeSpecialization rparen;
	| is lparen Type identifier equal TypeSpecialization comma TemplateParameterList rparen;

TypeSpecialization :=
	Type;
	| class;
	| const;
	| delegate;
	| enum;
	| function;
	| immutable;
	| inout;
	| interface;
	| return;
	| shared;
	| struct;
	| super;
	| union;

TraitsExpression :=
	traits lparen TraitsKeyword comma TraitsArguments rparen;

TraitsKeyword :=
	identifier;

TraitsArguments :=
	TraitsArgument;
	| TraitsArgument comma TraitsArguments;

TraitsArgument :=
	AssignExpression;
	| Type;

Statement :=
    semicolon;
    | NonEmptyStatement;
    | ScopeBlockStatement;

NoScopeNonEmptyStatement :=
    NonEmptyStatement;
    | BlockStatement;

NoScopeStatement :=
    semicolon;;
    | NonEmptyStatement;
    | BlockStatement;

NonEmptyOrScopeBlockStatement :=
    NonEmptyStatement;
    | ScopeBlockStatement;

NonEmptyStatement :=
    NonEmptyStatementNoCaseNoDefault;
    | CaseStatement;
    | CaseRangeStatement;
    | DefaultStatement;

NonEmptyStatementNoCaseNoDefault :=
    LabeledStatement;
    | ExpressionStatement;
    | DeclarationStatement;
    | IfStatement;
    | WhileStatement;
    | DoStatement;
    | ForStatement;
    | ForeachStatement;
    | SwitchStatement;
    | FinalSwitchStatement;
    | ContinueStatement;
    | BreakStatement;
    | ReturnStatement;
    | GotoStatement;
    | WithStatement;
    | SynchronizedStatement;
    | TryStatement;
    | ScopeGuardStatement;
    | ThrowStatement;
    | AsmStatement;
    | PragmaStatement;
    | MixinStatement;
    | ForeachRangeStatement;
    | ConditionalStatement;
    | StaticAssert;
    | TemplateMixin;
    | ImportDeclaration;

ScopeStatement :=
    NonEmptyStatement;
    | BlockStatement;

ScopeBlockStatement :=
    BlockStatement;

LabeledStatement :=
	identifier colon NoScopeStatement;

BlockStatement :=
	lcurly rcurly ;
	| lcurly StatementList rcurly;

StatementList :=
	Statement;
	| Statement StatementList;

ExpressionStatement :=
	Expression semicolon;

DeclarationStatement :=
	Declaration;

IfStatement :=
	if lparen IfCondition rparen ThenStatement;
	| if lparen IfCondition rparen ThenStatement else ElseStatement;

IfCondition :=
	Expression;
	| auto identifier assign Expression;
	| BasicType BasicTypes2 Declarator assign Expression;
	| BasicType Declarator assign Expression;

ThenStatement :=
	ScopeStatement;

ElseStatement :=
	ScopeStatement;

WhileStatement :=
	while lparen Expression rparen ScopeStatement;

DoStatement :=
	do ScopeStatement while lparen Expression rparen semicolon;

ForStatement :=
    for lparen Initialize Test semicolon Increment rparen ScopeStatement;
    | for lparen Initialize Test semicolon rparen ScopeStatement;
    | for lparen Initialize semicolon Increment rparen ScopeStatement;
    | for lparen Initialize semicolon rparen ScopeStatement;

Initialize :=
	semicolon;
	| NoScopeNonEmptyStatement;

// expression was opt
Test :=
	Expression;

// expression was opt
Increment :=
	Expression;

ForeachStatement :=
	Foreach lparen ForeachTypeList semicolon Aggregate rparen NoScopeNonEmptyStatement;

Foreach :=
	foreach;
	| foreach_reverse;

ForeachTypeList :=
	ForeachType;
	| ForeachType comma ForeachTypeList;

ForeachType :=
	ref Type identifier;
	| ref identifier;
	| Type identifier;
	| identifier;

Aggregate :=
	Expression;

SwitchStatement :=
	switch lparen Expression rparen ScopeStatement;

CaseStatement :=
	case ArgumentList colon ScopeStatementList;

CaseRangeStatement :=
	case FirstExp colon dotdot case LastExp colon ScopeStatementList;

FirstExp :=
	AssignExpression;

LastExp :=
	AssignExpression;

DefaultStatement :=
	default colon Statement;

ScopeStatementList :=
    StatementListNoCaseNoDefault;

StatementListNoCaseNoDefault :=
    StatementNoCaseNoDefault;
    | StatementNoCaseNoDefault StatementListNoCaseNoDefault;

StatementNoCaseNoDefault :=
    semicolon;
    | NonEmptyStatementNoCaseNoDefault;
    | ScopeBlockStatement;

FinalSwitchStatement :=
	final switch lparen Expression rparen ScopeStatement;

ContinueStatement :=
	continue semicolon;
	| continue identifier semicolon;

BreakStatement :=
	break semicolon;
	| break identifier semicolon;

ReturnStatement :=
	return semicolon;
	| return Expression semicolon;

GotoStatement :=
	goto identifier semicolon;
	| goto default semicolon;
	| goto case semicolon;
	| goto case Expression semicolon;

WithStatement :=
	with lparen Expression rparen ScopeStatement;
	| with lparen Symbol rparen ScopeStatement;
	| with lparen TemplateInstance rparen ScopeStatement;

SynchronizedStatement :=
	synchronized ScopeStatement;
	| synchronized lparen Expression rparen ScopeStatement;

TryStatement :=
	try ScopeStatement Catches;
	| try ScopeStatement Catches FinallyStatement;
	| try ScopeStatement FinallyStatement;

Catches :=
	LastCatch;
	| Catch;
	| Catch Catches;

LastCatch :=
	catch NoScopeNonEmptyStatement;

Catch :=
	catch lparen CatchParameter rparen NoScopeNonEmptyStatement;

CatchParameter :=
	BasicType identifier;

FinallyStatement :=
	finally NoScopeNonEmptyStatement;

ThrowStatement :=
	throw Expression semicolon;

ScopeGuardStatement :=
	scope lparen exit rparen NonEmptyOrScopeBlockStatement;
	| scope lparen success rparen NonEmptyOrScopeBlockStatement;
	| scope lparen failure rparen NonEmptyOrScopeBlockStatement;

AsmStatement :=
	asm lcurly rcurly;
	| asm lcurly AsmInstructionList rcurly;

AsmInstructionList :=
	AsmInstruction semicolon;
	| AsmInstruction semicolon AsmInstructionList;

PragmaStatement :=
	Pragma NoScopeStatement;

MixinStatement :=
	mixin lparen AssignExpression rparen semicolon;

ForeachRangeStatement :=
	Foreach lparen ForeachType semicolon LwrExpression dotdot UprExpression rparen ScopeStatement;

LwrExpression :=
	Expression;

UprExpression :=
	Expression;

AggregateDeclaration :=
	struct identifier StructBody;
	| union identifier StructBody;
	| struct identifier semicolon;
	| union identifier semicolon;
	| StructTemplateDeclaration;
	| UnionTemplateDeclaration;

StructBody :=
	lcurly StructBodyDeclarations rcurly;
	| lcurly rcurly;

StructBodyDeclarations :=
	StructBodyDeclaration;
	| StructBodyDeclaration StructBodyDeclarations;

StructBodyDeclaration :=
	DeclDef;
	| StructAllocator;
	| StructDeallocator;
	| StructPostblit;
	| AliasThis;
	
StructAllocator := 
	ClassAllocator;
	
StructDeallocator :=
	ClassDeallocator;

StructPostblit :=
	this lparen this rparen FunctionBody;

ClassDeclaration :=
	class identifier BaseClassList ClassBody;
	| class identifier ClassBody;
	| ClassTemplateDeclaration;

BaseClassList :=
	colon SuperClass;
	| colon SuperClass comma Interfaces;
	| Interfaces;

SuperClass :=
	identifier;

Interfaces :=
	Interface;
	| Interface comma Interfaces;

Interface :=
	identifier;

ClassBody :=
	lcurly rcurly;
	| lcurly ClassBodyDeclarations rcurly;

ClassBodyDeclarations :=
	ClassBodyDeclaration;
	| ClassBodyDeclaration ClassBodyDeclarations;

ClassBodyDeclaration :=
	DeclDef;
	| Invariant;
	| ClassAllocator;
	| ClassDeallocator;

Constructor :=
	this Parameters FunctionBody;
	| TemplatedConstructor;

TemplatedConstructor :=
    this lparen TemplateParameterList rparen Parameters Constraint FunctionBody;
    | this lparen TemplateParameterList rparen Parameters FunctionBody;

Destructor :=
	tilde this lparen rparen FunctionBody;

StaticConstructor :=
	static this lparen rparen FunctionBody;

StaticDestructor :=
	static tilde this lparen rparen FunctionBody;

SharedStaticConstructor :=
	shared static this lparen rparen FunctionBody;

SharedStaticDestructor :=
	shared static tilde this lparen rparen FunctionBody;

Invariant :=
	invariant lparen rparen BlockStatement;

ClassAllocator :=
	new Parameters FunctionBody;

ClassDeallocator :=
	delete Parameters FunctionBody;

AliasThis :=
	alias identifier this semicolon;

NewAnonClassExpression :=
	new AllocatorArguments class ClassArguments Interfaces ClassBody;
	| new AllocatorArguments class ClassArguments SuperClass ClassBody;
	| new AllocatorArguments class ClassArguments SuperClass Interfaces ClassBody;
	| new AllocatorArguments class Interfaces ClassBody;
	| new AllocatorArguments class SuperClass ClassBody;
	| new AllocatorArguments class SuperClass Interfaces ClassBody;
	| new class ClassArguments Interfaces ClassBody;
	| new class ClassArguments SuperClass ClassBody;
	| new class ClassArguments SuperClass Interfaces ClassBody;
	| new class ClassBody;
	| new class SuperClass Interfaces ClassBody;

ClassArguments :=
	lparen ArgumentList rparen;
	| lparen rparen;

InterfaceDeclaration :=
	interface identifier BaseInterfaceList InterfaceBody;
	| interface identifier InterfaceBody;
	| InterfaceTemplateDeclaration;

BaseInterfaceList :=
	colon Interfaces;

InterfaceBody :=
	lcurly DeclDefs rcurly;
	| lcurly rcurly;

EnumDeclaration := enum EnumBody; 
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| enum EnumTag EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| enum EnumTag colon EnumBaseType EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-4,-2,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| enum colon EnumBaseType EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

EnumTag :=
	identifier; 

EnumBaseType :=
	Type;

EnumBody :=
	semicolon;
	| lcurly EnumMembers rcurly; {: ret = this.tokenStack[-2]; :}

EnumMembers :=
	EnumMember;
	| EnumMembers comma EnumMember; {: ret = buildTreeWithLoc(termEnumMembers,
		[-3,-1], actionNum, this.tokenStack[-3].getLoc()); :}

EnumMember :=
	 identifier;
	 | identifier assign AssignExpression; 
	 	{: ret = buildTreeWithLoc(termEnumMember, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}

	 | Type identifier assign AssignExpression;
	 	{: ret = buildTreeWithLoc(termEnumMember, [-4,-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

FunctionBody :=
	 BlockStatement ;
	 | BodyStatement;
	 | InStatement BodyStatement;
	 | OutStatement BodyStatement;
	 | InStatement OutStatement BodyStatement;
	 | OutStatement InStatement BodyStatement;

InStatement :=
	 in BlockStatement;

OutStatement :=
	 out BlockStatement;
	 | out lparen identifier rparen BlockStatement;

BodyStatement :=
	 body BlockStatement;

ConditionalDeclaration :=
	 Condition DeclarationBlock;
	 | Condition DeclarationBlock else DeclarationBlock;

ConditionalStatement :=
	 Condition NoScopeNonEmptyStatement;
	 | Condition NoScopeNonEmptyStatement else NoScopeNonEmptyStatement;

Condition :=
	 VersionCondition;
	 | DebugCondition;
	 | StaticIfCondition;

VersionCondition :=
	 version lparen integer rparen;
	 | version lparen identifier rparen;
	 | version lparen unittest rparen;

VersionSpecification :=
	 version assign identifier semicolon;
	 | version assign integer semicolon;

DebugCondition :=
	 debug;
	 | debug lparen integer rparen;
	 | debug lparen identifier rparen;

DebugSpecification :=
	 debug assign identifier semicolon;
	 | debug assign integer semicolon;

StaticIfCondition :=
	 static if lparen AssignExpression rparen;

StaticAssert :=
	 static assert lparen AssignExpression rparen semicolon;
	 | static assert lparen AssignExpression comma AssignExpression rparen semicolon;

TemplateDeclaration :=
	template TemplateIdentifier lparen TemplateParameterList rparen Constraint lcurly DeclDefs rcurly;
	| template TemplateIdentifier lparen TemplateParameterList rparen lcurly DeclDefs rcurly;

TemplateIdentifier :=
	identifier;

TemplateParameterList :=
	TemplateParameter;
	| TemplateParameter comma;
	| TemplateParameter comma TemplateParameterList;

TemplateParameter :=
	TemplateTypeParameter;
	| TemplateValueParameter;
	| TemplateAliasParameter;
	| TemplateTupleParameter;
	| TemplateThisParameter;

TemplateTupleParameter :=
	identifier dotdotdot;

IdentifierOrTemplateInstance :=
	identifier;
	| TemplateInstance;

TemplateInstance :=
	TemplateIdentifier bang lparen TemplateArgumentList rparen;
	| TemplateIdentifier bang TemplateSingleArgument;

TemplateThisParameter :=
    this TemplateTypeParameter;

TemplateArgumentList :=
	TemplateArgument;
	| TemplateArgument comma;
	| TemplateArgument comma TemplateArgumentList;

TemplateArgument :=
	Type;
	| AssignExpression;
	| Symbol;

Symbol :=
	SymbolTail;
	| dot SymbolTail;

SymbolTail :=
	identifier;
	| identifier dot SymbolTail;
	| TemplateInstance;
	| TemplateInstance dot SymbolTail;

TemplateSingleArgument :=
	identifier;
	| BasicTypeX;
	| charliteral;
	| stringliteral;
	| integer;
	| floatliteral;
	| true;
	| false;
	| null;
	| file;
	| line;

TemplateTypeParameter :=
	identifier;
	| identifier TemplateTypeParameterSpecialization;
	| identifier TemplateTypeParameterDefault;
	| identifier TemplateTypeParameterSpecialization TemplateTypeParameterDefault;

TemplateTypeParameterSpecialization :=
	colon Type;

TemplateTypeParameterDefault :=
	assign Type;

TemplateValueParameter :=
    BasicType Declarator;
    | BasicType Declarator TemplateValueParameterSpecialization;
    | BasicType Declarator TemplateValueParameterDefault;
    | BasicType Declarator TemplateValueParameterSpecialization TemplateValueParameterDefault;

TemplateValueParameterSpecialization :=
    colon ConditionalExpression;

// already part of conditionalexpression
TemplateValueParameterDefault :=
	assign file;
	| assign line;

TemplateAliasParameter :=
	alias BasicType Declarator TemplateAliasParameterSpecialization TemplateAliasParameterDefault;
	| alias identifier TemplateAliasParameterSpecialization TemplateAliasParameterDefault;
	| alias identifier TemplateAliasParameterSpecialization;
	| alias identifier TemplateAliasParameterDefault;
	| alias identifier;
	| alias BasicType Declarator TemplateAliasParameterDefault;
	| alias BasicType Declarator TemplateAliasParameterSpecialization;
	| alias BasicType Declarator;

TemplateAliasParameterSpecialization :=
	colon Type;
	| colon ConditionalExpression;

TemplateAliasParameterDefault :=
	assign Type;
	| assign ConditionalExpression;

ClassTemplateDeclaration :=
	class identifier lparen TemplateParameterList rparen Constraint BaseClassList ClassBody;
	| class identifier lparen TemplateParameterList rparen BaseClassList ClassBody;
	| class identifier lparen TemplateParameterList rparen Constraint ClassBody;
	| class identifier lparen TemplateParameterList rparen ClassBody;

StructTemplateDeclaration :=
	struct identifier lparen TemplateParameterList rparen Constraint StructBody;
	| struct identifier lparen TemplateParameterList rparen StructBody;

UnionTemplateDeclaration :=
	union identifier lparen TemplateParameterList rparen Constraint StructBody;
	| union identifier lparen TemplateParameterList rparen StructBody;

InterfaceTemplateDeclaration :=
	interface identifier lparen TemplateParameterList rparen Constraint BaseInterfaceList InterfaceBody;
	| interface identifier lparen TemplateParameterList rparen Constraint InterfaceBody;
	| interface identifier lparen TemplateParameterList rparen InterfaceBody;
	| interface identifier lparen TemplateParameterList rparen BaseInterfaceList InterfaceBody;

TemplateMixinDeclaration :=
	mixin template TemplateIdentifier lparen TemplateParameterList rparen Constraint lcurly DeclDefs rcurly;
	| mixin template TemplateIdentifier lparen TemplateParameterList rparen lcurly DeclDefs rcurly;

Constraint :=
	if lparen ConstraintExpression rparen;

ConstraintExpression :=
	Expression;

TemplateMixin :=
	mixin TemplateIdentifier semicolon;
	| mixin TemplateIdentifier identifer semicolon;
	| mixin TemplateIdentifier bang lparen TemplateArgumentList rparen semicolon;
	| mixin TemplateIdentifier bang lparen TemplateArgumentList rparen semicolon identifier;

UnitTest :=
	unittest BlockStatement;

AsmInstruction :=
	stringliteral;
