%{
	BasicType2 := lbrack AssignExpression rbrack;
	DeclaratorSuffix := lbrack AssignExpression rback;
}%

%{
	Declarator := identifier;
	TemplateTypeParameter := identifier;
}%

//%right abstract auto const deprecated extern final immutable inout shared nothrow override pure ref scope static synchronized gshared thread
//%right dot

S := Module;

// checked
Module :=
	ModuleDeclaration DeclDefs; 
		{: ret = buildTreeWithLoc(termModule, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| DeclDefs;

// checked
ModuleDeclaration :=
	module ModuleFullyQualifiedName semicolon; 
		{: ret = buildTreeWithLoc(termModuleDeclaration, [-2], actionNum,
		this.tokenStack[-3].getLoc()); :}

// checked
ModuleFullyQualifiedName :=
	ModuleName;
	| Packages dot ModuleName; 
		{: ret = buildTreeWithLoc(termModuleFullyQualifiedName, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ModuleName :=
	identifier;

// checked
Packages :=
	PackageName;
	| Packages dot PackageName; 
		{: ret = buildTreeWithLoc(termPackages, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
PackageName :=
	identifier;

// checked
DeclDefs :=
	DeclDef;
	| DeclDef DeclDefs; 
		{: ret = buildTreeWithLoc(termDeclDefs, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
DeclDef :=
	AttributeSpecifier;
	| ImportDeclaration;
	| EnumDeclaration;
	| ClassDeclaration;
	| InterfaceDeclaration;
	| AggregateDeclaration;
	| Declaration;
	| Constructor;
	| Destructor;
	| UnitTest;
	| StaticConstructor;
	| StaticDestructor;
	| SharedStaticConstructor;
	| SharedStaticDestructor;
	| ConditionalDeclaration;
	| DebugSpecification;
	| VersionSpecification;
	| StaticAssert;
	| TemplateDeclaration;
	| TemplateMixinDeclaration;
	| TemplateMixin;
	| MixinDeclaration;
	| semicolon;

// checked
ImportDeclaration :=
	import ImportList semicolon; 
		{: ret = buildTreeWithLoc(termImportDeclaration, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}

	| static import ImportList semicolon; 
		{: ret = buildTreeWithLoc(termImportDeclaration, [-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}

// checked
ImportList :=
	Import; 
	| ImportBindings; 
	| Import comma ImportList; 
		{: ret = buildTreeWithLoc(termImportList, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
Import :=
	ModuleFullyQualifiedName; 
	| ModuleAliasIdentifier assign ModuleFullyQualifiedName; 
		{: ret = buildTreeWithLoc(termImport, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
ImportBindings :=
	Import colon ImportBindList; 
		{: ret = buildTreeWithLoc(termImportBindings, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
ImportBindList :=
	ImportBind;
	| ImportBind comma ImportBindList; 
		{: ret = buildTreeWithLoc(termImportBindList, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
ImportBind :=
	identifier;
	| identifier assign identifier; 
		{: ret = buildTreeWithLoc(termImportBind, [-3,-1], actionNum,
			this.tokenStack[-2].getLoc()); :}

// checked
ModuleAliasIdentifier :=
	identifier;

// checked
MixinDeclaration :=
	mixin lparen AssignExpression rparen semicolon; 
		{: ret = buildTreeWithLoc(termMixinDeclaration, [-3], actionNum,
			this.tokenStack[-5].getLoc()); :}

// checked
Declaration :=
	AliasDeclaration;
	| AliasThisDeclaration;
	| Decl;

// checked
AliasDeclaration :=
	alias BasicType Declarator; 
		{: ret = buildTreeWithLoc(termAliasDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	
// checked
AliasThisDeclaration := 
	alias identifier this;
		{: ret = buildTreeWithLoc(termAliasThisDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
Decl := 
	StorageClasses Decl; 
		{: ret = buildTreeWithLoc(termDecl, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType Declarators semicolon; 
		{: ret = buildTreeWithLoc(termDecl, [-3,-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType Declarator FunctionBody; 
		{: ret = buildTreeWithLoc(termDecl, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| AutoDeclaration;

// checked
Declarators :=
	DeclaratorInitializer;
	| DeclaratorInitializer comma DeclaratorIdentifierList; 
		{: ret = buildTreeWithLoc(termDeclarators, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
DeclaratorInitializer :=
	Declarator;
	| Declarator assign Initializer;
		{: ret = buildTreeWithLoc(termDeclaratorInitializer, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
DeclaratorIdentifierList :=
	DeclaratorIdentifier;
	| DeclaratorIdentifier comma DeclaratorIdentifierList;
		{: ret = buildTreeWithLoc(termDeclaratorIdentifierList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
DeclaratorIdentifier :=
	identifier;
	| identifier assign Initializer;
		{: ret = buildTreeWithLoc(termDeclaratorIdentifier, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AutoDeclaration := 
	StorageClasses AutoDeclarationX semicolon; 
		{: ret = buildTreeWithLoc(termAutoDeclaration, [-3,-2], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	
// checked
AutoDeclarationX := identifier assign Initializer;
		{: ret = buildTreeWithLoc(termAutoDeclarationX, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| AutoDeclarationX comma identifier assign Initializer;
		{: ret = buildTreeWithLoc(termAutoDeclarationX, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
BasicType :=
	BasicTypeX;
	| dot IdentifierList; 
		{: ret = buildTreeWithLoc(termBasicType, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| IdentifierList;
	| Typeof;
	| Typeof dot IdentifierList;
		{: ret = buildTreeWithLoc(termBasicType, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| const lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| immutable lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| shared lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| inout lparen Type rparen;
		{: ret = buildTreeWithLoc(termBasicType, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}

// checked
BasicTypeX :=
	bool;
	| byte;
	| ubyte;
	| short;
	| ushort;
	| int;
	| uint;
	| long;
	| ulong;
	| char;
	| wchar;
	| dchar;
	| float;
	| size_t;
	| double;
	| real;
	| ifloat;
	| idouble;
	| ireal;
	| cfloat;
	| cdouble;
	| creal;
	| void;

// checked
BasicType2 :=
	star;
	| lbrack rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lbrack AssignExpression rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-1], actionNum, 
			this.tokenStack[-1].getLoc()); :}
	| lbrack AssignExpression dotdot AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termBasicType2, [-4,-3,-2], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| lbrack Type rbrack ;
		{: ret = buildTreeWithLoc(termBasicType2, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| delegate Parameters FunctionAttributes;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| function Parameters FunctionAttributes;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| delegate Parameters;
		{: ret = buildTreeWithLoc(termBasicType2, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| function Parameters;
		{: ret = buildTreeWithLoc(termBasicType2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
Declarator :=
	BasicType2 identifier;
		{: ret = buildTreeWithLoc(termDeclarator, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType2 identifier DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType2 lparen Declarator rparen;
		{: ret = buildTreeWithLoc(termDeclarator, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| BasicType2 lparen Declarator rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-5,-3,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| identifier ;
	| identifier DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lparen Declarator rparen;
		{: ret = buildTreeWithLoc(termDeclarator, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lparen Declarator rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator, [-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

// checked
DeclaratorSuffixes :=
	DeclaratorSuffix;
	| DeclaratorSuffix DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclaratorSuffixes, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
DeclaratorSuffix :=
	lbrack rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| lbrack AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lbrack Type rbrack;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| Parameters;
	| Parameters Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| Parameters MemberFunctionAttributes Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| Parameters MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| TemplateParameterList Parameters Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters MemberFunctionAttributes Constraint;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| TemplateParameterList Parameters;
		{: ret = buildTreeWithLoc(termDeclaratorSuffix, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
IdentifierList :=
	identifier ;
	| identifier dot IdentifierList; 
		{: ret = buildTreeWithLoc(termIdentifierList, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| TemplateInstance ;
	| TemplateInstance dot IdentifierList; 
		{: ret = buildTreeWithLoc(termTemplateInstance, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
StorageClasses :=
	StorageClass;
	| StorageClass StorageClasses;
		{: ret = buildTreeWithLoc(termStorageClasses, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
StorageClass :=
	abstract;
	| auto;
	| const;
	| deprecated;
	| enum;
	| extern;
	| final;
	| immutable;
	| inout;
	| shared;
	| nothrow;
	| override;
	| pure;
	| gshared;
	| Property;
	| scope;
	| static;
	| synchronized;

// checked
Property :=
	disable;
	| safe;
	| system;
	| trusted;
	| property;

// checked
Type :=
	BasicType;
	| BasicType Declarator2;
		{: ret = buildTreeWithLoc(termType, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
Declarator2 :=
	BasicType2 DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType2;
	| DeclaratorSuffixes;
	| BasicType2 lparen Declarator2 rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-5,-3,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| lparen Declarator2 rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| BasicType2 lparen Declarator2 rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-4,-2], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| lparen Declarator2 rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType2 lparen rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-4,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| lparen rparen DeclaratorSuffixes;
		{: ret = buildTreeWithLoc(termDeclarator2, [-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType2 lparen rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-3], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lparen rparen;
		{: ret = buildTreeWithLoc(termDeclarator2, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
Parameters :=
	lparen ParameterList rparen;
		{: ret = buildTreeWithLoc(termParameters, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| lparen rparen;
		{: ret = buildTreeWithLoc(termParameters, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
ParameterList :=
	Parameter;
	| Parameter comma ParameterList;
		{: ret = buildTreeWithLoc(termParameterList, [-3,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| dotdotdot;

// checked
Parameter :=
	InOut BasicType Declarator;
		{: ret = buildTreeWithLoc(termParameter, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| InOut BasicType Declarator dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| InOut BasicType Declarator assign DefaultInitializerExpression;
		{: ret = buildTreeWithLoc(termParameter, [-5,-4,-3,-2,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| InOut Type;
		{: ret = buildTreeWithLoc(termParameter, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| InOut Type dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-3,-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType Declarator;
		{: ret = buildTreeWithLoc(termParameter, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| BasicType Declarator dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| BasicType Declarator assign DefaultInitializerExpression;
		{: ret = buildTreeWithLoc(termParameter, [-4,-3,-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}
	| Type;
		{: ret = buildTreeWithLoc(termParameter, [-1], actionNum, 
			this.tokenStack[-1].getLoc()); :}
	| Type dotdotdot;
		{: ret = buildTreeWithLoc(termParameter, [-2,-1], actionNum, 
			this.tokenStack[-1].getLoc()); :}

// checked
InOut :=
	InOutX;
	| InOut InOutX;
		{: ret = buildTreeWithLoc(termInOut, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
InOutX :=
	auto;
	| const;
	| final;
	| immutable;
	| in;
	| inout;
	| lazy;
	| out;
	| ref;
	| scope;
	| shared;

// checked
FunctionAttributes :=
	FunctionAttribute;
	| FunctionAttribute FunctionAttributes;
		{: ret = buildTreeWithLoc(termFunctionAttributes, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
FunctionAttribute :=
	nothrow;
	| pure;
	| Property;

// checked
MemberFunctionAttributes :=
	MemberFunctionAttribute;
	| MemberFunctionAttribute MemberFunctionAttributes;
		{: ret = buildTreeWithLoc(termMemberFunctionAttributes, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
MemberFunctionAttribute :=
	const;
	| immutable;
	| inout;
	| shared;
	| FunctionAttribute;

// checked
DefaultInitializerExpression := 
	AssignExpression;
	| file;
	| line;

// checked
Initializer :=
	VoidInitializer;
	| NonVoidInitializer;

// checked
NonVoidInitializer :=
	AssignExpression;
	| ArrayInitializer;
	| StructInitializer;

// checked
ArrayInitializer :=
	lbrack rbrack;
		{: ret = buildTreeWithLoc(termArrayInitializer, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| lbrack ArrayMemberInitializations rbrack;
		{: ret = buildTreeWithLoc(termArrayInitializer, [-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ArrayMemberInitializations :=
	ArrayMemberInitialization;
	| ArrayMemberInitialization comma;
		{: ret = buildTreeWithLoc(termArrayMemberInitializations, [-2], 
			actionNum, this.tokenStack[-1].getLoc()); :}
	| ArrayMemberInitialization comma ArrayMemberInitializations;
		{: ret = buildTreeWithLoc(termArrayMemberInitializations, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ArrayMemberInitialization :=
	NonVoidInitializer;
	| AssignExpression colon NonVoidInitializer;
		{: ret = buildTreeWithLoc(termArrayMemberInitialization, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
StructInitializer :=
	lcurly rcurly;
	| lcurly StructMemberInitializers rcurly;
		{: ret = buildTreeWithLoc(termStructInitializer, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
StructMemberInitializers :=
	StructMemberInitializer;
	| StructMemberInitializer comma;
		{: ret = buildTreeWithLoc(termStructMemberInitializers, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| StructMemberInitializers comma StructMemberInitializer;
		{: ret = buildTreeWithLoc(termStructMemberInitializers, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
StructMemberInitializer :=
	NonVoidInitializer;
	| identifier colon NonVoidInitializer;
		{: ret = buildTreeWithLoc(termStructMemberInitializer, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
Typeof :=
	typeof lparen Expression rparen;
		{: ret = buildTreeWithLoc(termTypeof, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| typeof lparen return rparen;
		{: ret = buildTreeWithLoc(termTypeof, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
VoidInitializer :=
	void;

// checked
AttributeSpecifier :=
	Attribute colon;
	| Attribute DeclarationBlock;
		{: ret = buildTreeWithLoc(termAttributeSpecifier, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
Attribute :=
	LinkageAttribute;
	| AlignAttribute;
	| Pragma;
	| deprecated;
	| ProtectionAttribute;
	| static;
	| extern;
	| final;
	| synchronized;
	| override;
	| abstract;
	| const;
	| auto;
	| scope;
	| gshared;
	| shared;
	| immutable;
	| inout;
	| disable;

// checked
DeclarationBlock :=
	DeclDef;
	| lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termDeclarationBlock, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lcurly rcurly;
		{: ret = buildTreeWithLoc(termDeclarationBlock, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
LinkageAttribute :=
	extern lparen identifier rparen;
		{: ret = buildTreeWithLoc(termLinkageAttribute, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
AlignAttribute :=
	align;
	| align lparen integer rparen;
		{: ret = buildTreeWithLoc(termAlignAttribute, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
ProtectionAttribute :=
	export;
	| package;
	| private;
	| protected;
	| public;

// checked
Pragma :=
	pragma lparen identifier rparen;
		{: ret = buildTreeWithLoc(termPragma, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| pragma lparen identifier comma ArgumentList rparen;
		{: ret = buildTreeWithLoc(termPragma, [-4,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
Expression :=
	CommaExpression;

// checked
CommaExpression :=
	AssignExpression;
	| AssignExpression comma CommaExpression;
		{: ret = buildTreeWithLoc(termCommaExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression plusassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression minusassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression starassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression divassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression moduloassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression andassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression orassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression xorassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression tildeassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression leftshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression rightshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ConditionalExpression xorxorassign AssignExpression;
		{: ret = buildTreeWithLoc(termAssignExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = buildTreeWithLoc(termConditionalExpression, [-5,-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicalor AndAndExpression;
		{: ret = buildTreeWithLoc(termOrOrExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AndAndExpression :=
	OrExpression;
	| AndAndExpression logicaland OrExpression;
		{: ret = buildTreeWithLoc(termAndAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| CmpExpression;
	| AndAndExpression logicaland CmpExpression;
		{: ret = buildTreeWithLoc(termAndAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
OrExpression :=
	XorExpression;
	| OrExpression or XorExpression;
		{: ret = buildTreeWithLoc(termOrExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression;
		{: ret = buildTreeWithLoc(termXorExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AndExpression :=
	ShiftExpression ;
	| AndExpression and ShiftExpression;
		{: ret = buildTreeWithLoc(termAndExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
CmpExpression :=
	ShiftExpression;
	| EqualExpression;
	| IdentityExpression;
	| RelExpression;
	| InExpression;

// checked
EqualExpression :=
	ShiftExpression equal ShiftExpression;
		{: ret = buildTreeWithLoc(termEqualExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression notequal ShiftExpression;
		{: ret = buildTreeWithLoc(termEqualExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
IdentityExpression :=
	ShiftExpression is ShiftExpression;
		{: ret = buildTreeWithLoc(termIdentityExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangis ShiftExpression;
		{: ret = buildTreeWithLoc(termIdentityExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
RelExpression :=
	ShiftExpression less ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression lessequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression greater ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression greaterequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangsquareassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangsquare ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression square ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression squareassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banggreater ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banggreaterassign ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangless ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression banglessequal ShiftExpression;
		{: ret = buildTreeWithLoc(termRelExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
InExpression :=
	ShiftExpression in ShiftExpression;
		{: ret = buildTreeWithLoc(termInExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression bangin ShiftExpression;
		{: ret = buildTreeWithLoc(termInExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression rightshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ShiftExpression unsignedrightshift AddExpression;
		{: ret = buildTreeWithLoc(termShiftExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AddExpression :=
	MulExpression;
	| CatExpression;
	| AddExpression plus MulExpression;
		{: ret = buildTreeWithLoc(termAddExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| AddExpression minus MulExpression;
		{: ret = buildTreeWithLoc(termAddExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
CatExpression :=
	AddExpression tilde MulExpression;
		{: ret = buildTreeWithLoc(termCatExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
MulExpression :=
	UnaryExpression;
	| MulExpression star UnaryExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| MulExpression div UnaryExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| MulExpression modulo UnaryExpression;
		{: ret = buildTreeWithLoc(termMulExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
PowExpression :=
	PostfixExpression;
	| PostfixExpression xorxor UnaryExpression;
		{: ret = buildTreeWithLoc(termPowExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
UnaryExpression :=
	and UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| increment UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| decrement UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| star UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| minus UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| plus UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| bang UnaryExpression;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ComplementExpression;
	| lparen Type rparen dot identifier;
		{: ret = buildTreeWithLoc(termUnaryExpression, [-4,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| NewExpression;
	| DeleteExpression;
	| CastExpression;
	| PowExpression;

// checked
ComplementExpression := 
	tilde UnaryExpression;
		{: ret = buildTreeWithLoc(termComplementExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
NewExpression := 
	new AllocatorArguments Type lbrack AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termNewExpression, [-5,-4,-2], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new Type lbrack AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termNewExpression, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| new AllocatorArguments Type lparen ArgumentList lparen;
		{: ret = buildTreeWithLoc(termNewExpression, [-5,-4,-2], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new Type lparen ArgumentList lparen;
		{: ret = buildTreeWithLoc(termNewExpression, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| new AllocatorArguments Type;
		{: ret = buildTreeWithLoc(termNewExpression, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| new Type;
		{: ret = buildTreeWithLoc(termNewExpression, [-1], 
			actionNum, this.tokenStack[-1].getLoc()); :}
	| NewAnonClassExpression;

// checked
AllocatorArguments :=
	lparen ArgumentList rparen;
		{: ret = buildTreeWithLoc(termAllocatorArguments, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lparen rparen;
		{: ret = buildTreeWithLoc(termAllocatorArguments, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ArgumentList :=
	AssignExpression ;
	| AssignExpression comma;
		{: ret = buildTreeWithLoc(termArgumentList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| AssignExpression comma ArgumentList;
		{: ret = buildTreeWithLoc(termArgumentList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
DeleteExpression :=
	delete UnaryExpression;
		{: ret = buildTreeWithLoc(termDeleteExpression, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
CastExpression :=
	cast lparen Type rparen UnaryExpression;
		{: ret = buildTreeWithLoc(termCastExpression, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| cast lparen CastQual rparen UnaryExpression;
		{: ret = buildTreeWithLoc(termCastExpression, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| cast lparen rparen UnaryExpression;
		{: ret = buildTreeWithLoc(termCastExpression, [-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
CastQual :=
	const;
	| const shared;
		{: ret = buildTreeWithLoc(termCastQual, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| shared const;
		{: ret = buildTreeWithLoc(termCastQual, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| inout;
	| inout shared;
		{: ret = buildTreeWithLoc(termCastQual, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| shared inout;
		{: ret = buildTreeWithLoc(termCastQual, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| immutable;
	| shared;

// not clear if its an PostfixExpression of UnaryExpression
// Unary would make sense though it's need to new Objects
// NewExpression was missing
// checked
PostfixExpression :=
	PrimaryExpression;
	| PostfixExpression dot identifier;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| PostfixExpression dot TemplateInstance;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| PostfixExpression dot NewExpression;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| PostfixExpression increment;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| PostfixExpression decrement;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| PostfixExpression lparen rparen;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| PostfixExpression lparen ArgumentList rparen;
		{: ret = buildTreeWithLoc(termPostfixExpression, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| IndexExpression;
	| SliceExpression;

// checked
IndexExpression :=
	PostfixExpression lbrack ArgumentList rbrack;
		{: ret = buildTreeWithLoc(termIndexExpression, [-4,-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
SliceExpression :=
	PostfixExpression lbrack rbrack;
		{: ret = buildTreeWithLoc(termSliceExpression, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| PostfixExpression lbrack AssignExpression dotdot AssignExpression rbrack;
		{: ret = buildTreeWithLoc(termSliceExpression, [-6,-4,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
PrimaryExpression :=
	identifier;
	| dot identifier;
		{: ret = buildTreeWithLoc(termPrimaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| TemplateInstance;
	| dot TemplateInstance;
		{: ret = buildTreeWithLoc(termPrimaryExpression, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| this;
	| super;
	| null;
	| true;
	| false;
	| dollarsym;
	| file;
	| line;
	| integer;
	| floatliteral;
	| charliteral;
	| stringliteral;
	| ArrayLiteral;
	| AssocArrayLiteral;
	| Lambda;
	| FunctionLiteral;
	| AssertExpression;
	| MixinExpression;
	| ImportExpression;
	| BasicType dot identifier;
		{: ret = buildTreeWithLoc(termPrimaryExpression, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| Typeof;
	| TypeidExpression;
	| IsExpression;
	| lparen Expression rparen;
		{: ret = buildTreeWithLoc(termPrimaryExpression, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| TraitsExpression;

// checked
ArrayLiteral :=
	lbrack ArgumentList rbrack;
		{: ret = buildTreeWithLoc(termArrayLiteral, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
AssocArrayLiteral :=
	lbrack KeyValuePairs rbrack;
		{: ret = buildTreeWithLoc(termAssocArrayLiteral, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
KeyValuePairs :=
	KeyValuePair;
	| KeyValuePair comma KeyValuePairs;
		{: ret = buildTreeWithLoc(termKeyValuePairs, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
KeyValuePair :=
	KeyExpression colon ValueExpression;
		{: ret = buildTreeWithLoc(termKeyValuePair, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
KeyExpression :=
	AssignExpression;

// checked
ValueExpression :=
	AssignExpression;

// checked
Lambda :=
	identifier arrow AssignExpression;
		{: ret = buildTreeWithLoc(termLambda, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| ParameterAttributes arrow AssignExpression;
		{: ret = buildTreeWithLoc(termLambda, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
FunctionLiteral :=
	function Type ParameterAttributes FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-4,-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| function ParameterAttributes FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| function Type FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| function FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| delegate Type ParameterAttributes FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-4,-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| delegate ParameterAttributes FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| delegate Type FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| delegate FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| ParameterAttributes FunctionBody;
		{: ret = buildTreeWithLoc(termFunctionLiteral, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| FunctionBody;

// checked
ParameterAttributes :=
	Parameters;
	| Parameters FunctionAttributes;
		{: ret = buildTreeWithLoc(termParameterAttributes, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AssertExpression :=
	assert lparen AssignExpression rparen;
		{: ret = buildTreeWithLoc(termAssertExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| assert lparen AssignExpression comma AssignExpression rparen;
		{: ret = buildTreeWithLoc(termAssertExpression, [-4,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
MixinExpression :=
	mixin lparen AssignExpression rparen;
		{: ret = buildTreeWithLoc(termMixinExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
ImportExpression :=
	import lparen AssignExpression rparen;
		{: ret = buildTreeWithLoc(termImportExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
TypeidExpression :=
	typeid lparen Type rparen;
		{: ret = buildTreeWithLoc(termTypeidExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| typeid lparen Expression rparen;
		{: ret = buildTreeWithLoc(termTypeidExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
IsExpression :=
	is lparen Type rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| is lparen Type colon TypeSpecialization rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-4,-3,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| is lparen Type equal TypeSpecialization rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-4,-3,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| is lparen Type identifier rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-3,-2], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| is lparen Type identifier colon TypeSpecialization rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-5,-4,-3,-2], 
			actionNum, this.tokenStack[-7].getLoc()); :}
	| is lparen Type identifier equal TypeSpecialization rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-5,-4,-3,-2], 
			actionNum, this.tokenStack[-7].getLoc()); :}
	| is lparen Type identifier colon TypeSpecialization comma TemplateParameterList rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-6,-5,-4,-3,-2], 
			actionNum, this.tokenStack[-8].getLoc()); :}
	| is lparen Type identifier equal TypeSpecialization comma TemplateParameterList rparen;
		{: ret = buildTreeWithLoc(termIsExpression, [-6,-5,-4,-3,-2], 
			actionNum, this.tokenStack[-8].getLoc()); :}

// checked
TypeSpecialization :=
	Type;
	| class;
	| const;
	| delegate;
	| enum;
	| function;
	| immutable;
	| inout;
	| interface;
	| return;
	| shared;
	| struct;
	| super;
	| union;

// checked
TraitsExpression :=
	traits lparen TraitsKeyword comma TraitsArguments rparen;
		{: ret = buildTreeWithLoc(termTraitsExpression, [-4,-2], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
TraitsKeyword :=
	identifier;

// checked
TraitsArguments :=
	TraitsArgument;
	| TraitsArgument comma TraitsArguments;
		{: ret = buildTreeWithLoc(termTraitsArguments, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
TraitsArgument :=
	AssignExpression;
	| Type;

// checked
Statement :=
    semicolon;
    | NonEmptyStatement;
    | ScopeBlockStatement;

// checked
NoScopeNonEmptyStatement :=
    NonEmptyStatement;
    | BlockStatement;

// checked
NoScopeStatement :=
    semicolon;
    | NonEmptyStatement;
    | BlockStatement;

// checked
NonEmptyOrScopeBlockStatement :=
    NonEmptyStatement;
    | ScopeBlockStatement;

// checked
NonEmptyStatement :=
    NonEmptyStatementNoCaseNoDefault;
    | CaseStatement;
    | CaseRangeStatement;
    | DefaultStatement;

// checked
NonEmptyStatementNoCaseNoDefault :=
    LabeledStatement;
    | ExpressionStatement;
    | DeclarationStatement;
    | IfStatement;
    | WhileStatement;
    | DoStatement;
    | ForStatement;
    | ForeachStatement;
    | SwitchStatement;
    | FinalSwitchStatement;
    | ContinueStatement;
    | BreakStatement;
    | ReturnStatement;
    | GotoStatement;
    | WithStatement;
    | SynchronizedStatement;
    | TryStatement;
    | ScopeGuardStatement;
    | ThrowStatement;
    | AsmStatement;
    | PragmaStatement;
    | MixinStatement;
    | ForeachRangeStatement;
    | ConditionalStatement;
    | StaticAssert;
    | TemplateMixin;
    | ImportDeclaration;

// checked
ScopeStatement :=
    NonEmptyStatement;
    | BlockStatement;

// checked
ScopeBlockStatement :=
    BlockStatement;

// checked
LabeledStatement :=
	identifier colon NoScopeStatement;
		{: ret = buildTreeWithLoc(termLabeledStatement, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
BlockStatement :=
	lcurly rcurly ;
		{: ret = buildTreeWithLoc(termBlockStatement, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| lcurly StatementList rcurly;
		{: ret = buildTreeWithLoc(termBlockStatement, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
StatementList :=
	Statement;
	| Statement StatementList;
		{: ret = buildTreeWithLoc(termStatementList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ExpressionStatement :=
	Expression semicolon;
		{: ret = buildTreeWithLoc(termExpressionStatement, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
DeclarationStatement :=
	Declaration;

// checked
IfStatement :=
	if lparen IfCondition rparen ThenStatement;
		{: ret = buildTreeWithLoc(termIfStatement, [-4,-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| if lparen IfCondition rparen ThenStatement else ElseStatement;
		{: ret = buildTreeWithLoc(termIfStatement, [-5,-3,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}

// checked
IfCondition :=
	Expression;
	| auto identifier assign Expression;
		{: ret = buildTreeWithLoc(termIfCondition, [-4,-3,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| BasicType Declarator assign Expression;
		{: ret = buildTreeWithLoc(termIfCondition, [-4,-3,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
ThenStatement :=
	ScopeStatement;

// checked
ElseStatement :=
	ScopeStatement;

// checked
WhileStatement :=
	while lparen Expression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termWhileStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
DoStatement :=
	do ScopeStatement while lparen Expression rparen semicolon;
		{: ret = buildTreeWithLoc(termDoStatement, [-6,-3], 
			actionNum, this.tokenStack[-7].getLoc()); :}

// checked
ForStatement :=
    for lparen Initialize Test semicolon Increment rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termForStatement, [-6,-5,-3,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
    | for lparen Initialize Test semicolon rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termForStatement, [-5,-4,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
    | for lparen Initialize semicolon Increment rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termForStatement, [-5,-3,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
    | for lparen Initialize semicolon rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termForStatement, [-4,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
Initialize :=
	semicolon;
	| NoScopeNonEmptyStatement;

// expression was opt
// checked
Test :=
	Expression;

// expression was opt
// checked
Increment :=
	Expression;

// checked
ForeachStatement :=
	Foreach lparen ForeachTypeList semicolon Aggregate rparen NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termForeachStatement, [-5,-3,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}

// checked
Foreach :=
	foreach;
	| foreach_reverse;

// checked
ForeachTypeList :=
	ForeachType;
	| ForeachType comma ForeachTypeList;
		{: ret = buildTreeWithLoc(termForeachTypeList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ForeachType :=
	ref BasicType Declarator;
		{: ret = buildTreeWithLoc(termForeachTypeList, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| ref identifier;
		{: ret = buildTreeWithLoc(termForeachTypeList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| BasicType identifier;
		{: ret = buildTreeWithLoc(termForeachTypeList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| identifier;

// checked
Aggregate :=
	Expression;

// checked
SwitchStatement :=
	switch lparen Expression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termSwitchStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
CaseStatement :=
	case ArgumentList colon ScopeStatementList;
		{: ret = buildTreeWithLoc(termCaseStatement, [-3,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
CaseRangeStatement :=
	case FirstExp colon dotdot case LastExp colon ScopeStatementList;
		{: ret = buildTreeWithLoc(termCaseRangeStatement, [-7,-3,-1], 
			actionNum, this.tokenStack[-8].getLoc()); :}

// checked
FirstExp :=
	AssignExpression;

// checked
LastExp :=
	AssignExpression;

// checked
DefaultStatement :=
	default colon ScopeStatementList;
		{: ret = buildTreeWithLoc(termDefaultStatement, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ScopeStatementList :=
    StatementListNoCaseNoDefault;

// checked
StatementListNoCaseNoDefault :=
    StatementNoCaseNoDefault;
    | StatementNoCaseNoDefault StatementListNoCaseNoDefault;
		{: ret = buildTreeWithLoc(termStatementListNoCaseNoDefault, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
StatementNoCaseNoDefault :=
    semicolon;
    | NonEmptyStatementNoCaseNoDefault;
    | ScopeBlockStatement;

// checked
FinalSwitchStatement :=
	final switch lparen Expression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termFinalSwitchStatement, [-3,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
ContinueStatement :=
	continue semicolon;
		{: ret = buildTreeWithLoc(termFinalSwitchStatement, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| continue identifier semicolon;
		{: ret = buildTreeWithLoc(termFinalSwitchStatement, [-3,-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
BreakStatement :=
	break semicolon;
		{: ret = buildTreeWithLoc(termBreakStatement, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| break identifier semicolon;
		{: ret = buildTreeWithLoc(termBreakStatement, [-3,-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ReturnStatement :=
	return semicolon;
		{: ret = buildTreeWithLoc(termReturnStatement, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| return Expression semicolon;
		{: ret = buildTreeWithLoc(termReturnStatement, [-3,-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
GotoStatement :=
	goto identifier semicolon;
		{: ret = buildTreeWithLoc(termGotoStatement, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| goto default semicolon;
		{: ret = buildTreeWithLoc(termGotoStatement, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| goto case semicolon;
		{: ret = buildTreeWithLoc(termGotoStatement, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| goto case Expression semicolon;
		{: ret = buildTreeWithLoc(termGotoStatement, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
WithStatement :=
	with lparen Expression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termWithStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| with lparen Symbol rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termWithStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| with lparen TemplateInstance rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termWithStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
SynchronizedStatement :=
	synchronized ScopeStatement;
		{: ret = buildTreeWithLoc(termSynchronizedStatement, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| synchronized lparen Expression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termSynchronizedStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
TryStatement :=
	try ScopeStatement Catches;
		{: ret = buildTreeWithLoc(termTryStatement, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| try ScopeStatement Catches FinallyStatement;
		{: ret = buildTreeWithLoc(termTryStatement, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| try ScopeStatement FinallyStatement;
		{: ret = buildTreeWithLoc(termTryStatement, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
Catches :=
	LastCatch;
	| Catch;
	| Catch Catches;
		{: ret = buildTreeWithLoc(termCatches, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
LastCatch :=
	catch NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termLastCatch, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
Catch :=
	catch lparen CatchParameter rparen NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termCatch, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
CatchParameter :=
	BasicType identifier;
		{: ret = buildTreeWithLoc(termCatchParameter, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
FinallyStatement :=
	finally NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termFinallyStatement, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ThrowStatement :=
	throw Expression semicolon;
		{: ret = buildTreeWithLoc(termThrowStatement, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ScopeGuardStatement :=
	scope lparen exit rparen NonEmptyOrScopeBlockStatement;
		{: ret = buildTreeWithLoc(termScopeGuardStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| scope lparen success rparen NonEmptyOrScopeBlockStatement;
		{: ret = buildTreeWithLoc(termScopeGuardStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| scope lparen failure rparen NonEmptyOrScopeBlockStatement;
		{: ret = buildTreeWithLoc(termScopeGuardStatement, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
AsmStatement :=
	asm lcurly rcurly;
		{: ret = buildTreeWithLoc(termAsmStatement, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| asm lcurly AsmInstructionList rcurly;
		{: ret = buildTreeWithLoc(termAsmStatement, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
AsmInstructionList :=
	AsmInstruction semicolon;
		{: ret = buildTreeWithLoc(termAsmInstructionList, [-2], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| AsmInstruction semicolon AsmInstructionList;
		{: ret = buildTreeWithLoc(termAsmInstructionList, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
PragmaStatement :=
	Pragma NoScopeStatement;
		{: ret = buildTreeWithLoc(termPragmaStatement, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
MixinStatement :=
	mixin lparen AssignExpression rparen semicolon;
		{: ret = buildTreeWithLoc(termMixinStatement, [-3], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
ForeachRangeStatement :=
	Foreach lparen ForeachType semicolon LwrExpression dotdot UprExpression rparen ScopeStatement;
		{: ret = buildTreeWithLoc(termForeachRangeStatement, [-7,-5,-3,-1], 
			actionNum, this.tokenStack[-9].getLoc()); :}

// checked
LwrExpression :=
	Expression;

// checked
UprExpression :=
	Expression;

// checked
AggregateDeclaration :=
	struct identifier StructBody;
		{: ret = buildTreeWithLoc(termAggregateDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| union identifier StructBody;
		{: ret = buildTreeWithLoc(termAggregateDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| struct identifier semicolon;
		{: ret = buildTreeWithLoc(termAggregateDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| union identifier semicolon;
		{: ret = buildTreeWithLoc(termAggregateDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| StructTemplateDeclaration;
	| UnionTemplateDeclaration;

// checked
StructBody :=
	lcurly StructBodyDeclarations rcurly;
		{: ret = buildTreeWithLoc(termStructBody, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lcurly rcurly;
		{: ret = buildTreeWithLoc(termStructBody, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
StructBodyDeclarations :=
	StructBodyDeclaration;
	| StructBodyDeclaration StructBodyDeclarations;
		{: ret = buildTreeWithLoc(termStructBodyDeclarations, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
StructBodyDeclaration :=
	DeclDef;
	| StructAllocator;
	| StructDeallocator;
	| StructPostblit;
	| AliasThis;
	
// checked
StructAllocator := 
	ClassAllocator;

// checked	
StructDeallocator :=
	ClassDeallocator;

// checked
StructPostblit :=
	this lparen this rparen FunctionBody;
		{: ret = buildTreeWithLoc(termStructPostblit, [-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
ClassDeclaration :=
	class identifier BaseClassList ClassBody;
		{: ret = buildTreeWithLoc(termClassDeclaration, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| class identifier ClassBody;
		{: ret = buildTreeWithLoc(termClassDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| ClassTemplateDeclaration;

// checked
BaseClassList :=
	colon SuperClass;
		{: ret = buildTreeWithLoc(termBaseClassList, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| colon SuperClass comma Interfaces;
		{: ret = buildTreeWithLoc(termBaseClassList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| Interfaces;

// checked
SuperClass :=
	identifier;

// checked
Interfaces :=
	Interface;
	| Interface comma Interfaces;
		{: ret = buildTreeWithLoc(termInterfaces, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
Interface :=
	identifier;

// checked
ClassBody :=
	lcurly rcurly;
	| lcurly ClassBodyDeclarations rcurly;
		{: ret = buildTreeWithLoc(termInterfaces, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ClassBodyDeclarations :=
	ClassBodyDeclaration;
	| ClassBodyDeclaration ClassBodyDeclarations;
		{: ret = buildTreeWithLoc(termClassBodyDeclarations, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ClassBodyDeclaration :=
	DeclDef;
	| Invariant;
	| ClassAllocator;
	| ClassDeallocator;

// checked
Constructor :=
	this Parameters FunctionBody;
		{: ret = buildTreeWithLoc(termConstructor, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| TemplatedConstructor;

// checked
TemplatedConstructor :=
    this lparen TemplateParameterList rparen Parameters Constraint FunctionBody;
		{: ret = buildTreeWithLoc(termTemplatedConstructor, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
    | this lparen TemplateParameterList rparen Parameters FunctionBody;
		{: ret = buildTreeWithLoc(termTemplatedConstructor, [-4,-2,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
Destructor :=
	tilde this lparen rparen FunctionBody;
		{: ret = buildTreeWithLoc(termDestructor, [-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
StaticConstructor :=
	static this lparen rparen FunctionBody;
		{: ret = buildTreeWithLoc(termStaticConstructor, [-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
StaticDestructor :=
	static tilde this lparen rparen FunctionBody;
		{: ret = buildTreeWithLoc(termStaticDestructor, [-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
SharedStaticConstructor :=
	shared static this lparen rparen FunctionBody;
		{: ret = buildTreeWithLoc(termSharedStaticConstructor, [-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
SharedStaticDestructor :=
	shared static tilde this lparen rparen FunctionBody;
		{: ret = buildTreeWithLoc(termSharedStaticDestructor, [-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}

// checked
Invariant :=
	invariant lparen rparen BlockStatement;
		{: ret = buildTreeWithLoc(termInvariant, [-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
ClassAllocator :=
	new Parameters FunctionBody;
		{: ret = buildTreeWithLoc(termClassAllocator, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
ClassDeallocator :=
	delete Parameters FunctionBody;
		{: ret = buildTreeWithLoc(termClassDeallocator, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
AliasThis :=
	alias identifier this semicolon;
		{: ret = buildTreeWithLoc(termAliasThis, [-3], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
NewAnonClassExpression :=
	new AllocatorArguments class ClassArguments Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| new AllocatorArguments class ClassArguments SuperClass ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| new AllocatorArguments class ClassArguments SuperClass Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, 
			[-6,-4,-3,-2,-1], actionNum, this.tokenStack[-7].getLoc()); :}
	| new AllocatorArguments class Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-4,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new AllocatorArguments class SuperClass ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-4,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new AllocatorArguments class SuperClass Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-5,-3,-2,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| new class ClassArguments Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new class ClassArguments SuperClass ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| new class ClassArguments SuperClass Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-4,-3,-2,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	| new class ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| new class SuperClass Interfaces ClassBody;
		{: ret = buildTreeWithLoc(termNewAnonClassExpression, [-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
ClassArguments :=
	lparen ArgumentList rparen;
		{: ret = buildTreeWithLoc(termClassArguments, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lparen rparen;
		{: ret = buildTreeWithLoc(termClassArguments, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
InterfaceDeclaration :=
	interface identifier BaseInterfaceList InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceDeclaration, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| interface identifier InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| InterfaceTemplateDeclaration;

// checked, need to check if InterfaceClasses are BaseClassList
BaseInterfaceList :=
	colon BaseClassList;
		{: ret = buildTreeWithLoc(termBaseInterfaceList, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
InterfaceBody :=
	lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termInterfaceBody, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lcurly rcurly;
		{: ret = buildTreeWithLoc(termInterfaceBody, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
EnumDeclaration := enum EnumBody; 
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| enum EnumTag EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	| enum EnumTag colon EnumBaseType EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-4,-2,-1], actionNum, 
			this.tokenStack[-5].getLoc()); :}
	| enum colon EnumBaseType EnumBody;
		{: ret = buildTreeWithLoc(termEnumDeclaration, [-2,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

// checked
EnumTag :=
	identifier; 

// checked
EnumBaseType :=
	Type;

// checked
EnumBody :=
	semicolon;
	| lcurly EnumMembers rcurly; 
		{: ret = buildTreeWithLoc(termEnumBody, [-2], actionNum, 
			this.tokenStack[-3].getLoc()); :}

// checked
EnumMembers :=
	EnumMember;
	| EnumMembers comma; 
		{: ret = buildTreeWithLoc(termEnumMembers, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	| EnumMembers comma EnumMember; 
		{: ret = buildTreeWithLoc(termEnumMembers, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}

// checked
EnumMember :=
	 identifier;
	 | identifier assign AssignExpression; 
		{: ret = buildTreeWithLoc(termEnumMember, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	 | Type assign AssignExpression;
		{: ret = buildTreeWithLoc(termEnumMember, [-3,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}

// checked
FunctionBody :=
	 BlockStatement ;
	 | BodyStatement;
	 | InStatement BodyStatement;
		{: ret = buildTreeWithLoc(termFunctionBody, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	 | OutStatement BodyStatement;
		{: ret = buildTreeWithLoc(termFunctionBody, [-2,-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	 | InStatement OutStatement BodyStatement;
		{: ret = buildTreeWithLoc(termFunctionBody, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}
	 | OutStatement InStatement BodyStatement;
		{: ret = buildTreeWithLoc(termFunctionBody, [-3,-2,-1], actionNum, 
			this.tokenStack[-3].getLoc()); :}

// checked
InStatement :=
	 in BlockStatement;
		{: ret = buildTreeWithLoc(termInStatement, [-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
OutStatement :=
	 out BlockStatement;
		{: ret = buildTreeWithLoc(termOutStatement, [-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}
	 | out lparen identifier rparen BlockStatement;
		{: ret = buildTreeWithLoc(termOutStatement, [-3,-1], actionNum, 
			this.tokenStack[-4].getLoc()); :}

// checked
BodyStatement :=
	 body BlockStatement;
		{: ret = buildTreeWithLoc(termBodyStatement, [-1], actionNum, 
			this.tokenStack[-2].getLoc()); :}

// checked
ConditionalDeclaration :=
	 Condition CCDeclarationBlock;
		{: ret = buildTreeWithLoc(termConditionalDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	 | Condition CCDeclarationBlock else CCDeclarationBlock;
		{: ret = buildTreeWithLoc(termConditionalDeclaration, [-4,-3,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | Condition colon Declarations;
		{: ret = buildTreeWithLoc(termConditionalDeclaration, [-3,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
CCDeclarationBlock :=
	Declaration;
	| lcurly Declarations rcurly;
		{: ret = buildTreeWithLoc(termCCDeclarationBlock, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| lcurly rcurly;
		{: ret = buildTreeWithLoc(termCCDeclarationBlock, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
Declarations :=
	Declaration;
	| Declaration Declarations;
		{: ret = buildTreeWithLoc(termDeclarations, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ConditionalStatement :=
	 Condition NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termConditionalDeclaration, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	 | Condition NoScopeNonEmptyStatement else NoScopeNonEmptyStatement;
		{: ret = buildTreeWithLoc(termConditionalDeclaration, [-5,-4,-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
Condition :=
	 VersionCondition;
	 | DebugCondition;
	 | StaticIfCondition;

// checked
VersionCondition :=
	 version lparen integer rparen;
		{: ret = buildTreeWithLoc(termVersionCondition, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | version lparen identifier rparen;
		{: ret = buildTreeWithLoc(termVersionCondition, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | version lparen unittest rparen;
		{: ret = buildTreeWithLoc(termVersionCondition, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
VersionSpecification :=
	 version assign identifier semicolon;
		{: ret = buildTreeWithLoc(termVersionSpecification, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | version assign integer semicolon;
		{: ret = buildTreeWithLoc(termVersionSpecification, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
DebugCondition :=
	 debug;
	 | debug lparen integer rparen;
		{: ret = buildTreeWithLoc(termDebugCondition, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | debug lparen identifier rparen;
		{: ret = buildTreeWithLoc(termDebugCondition, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
DebugSpecification :=
	 debug assign identifier semicolon;
		{: ret = buildTreeWithLoc(termDebugSpecification, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	 | debug assign integer semicolon;
		{: ret = buildTreeWithLoc(termDebugSpecification, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
StaticIfCondition :=
	 static if lparen AssignExpression rparen;
		{: ret = buildTreeWithLoc(termStaticIfCondition, [-2], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
StaticAssert :=
	 static assert lparen AssignExpression rparen semicolon;
		{: ret = buildTreeWithLoc(termStaticAssert, [-3], 
			actionNum, this.tokenStack[-6].getLoc()); :}
	 | static assert lparen AssignExpression comma AssignExpression rparen semicolon;
		{: ret = buildTreeWithLoc(termStaticAssert, [-5,-3], 
			actionNum, this.tokenStack[-8].getLoc()); :}

// checked
TemplateDeclaration :=
	template TemplateIdentifier lparen TemplateParameterList rparen Constraint lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termTemplateDeclaration, [-8,-6,-4,-2], 
			actionNum, this.tokenStack[-9].getLoc()); :}
	| template TemplateIdentifier lparen TemplateParameterList rparen lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termTemplateDeclaration, [-7,-5,-2], 
			actionNum, this.tokenStack[-8].getLoc()); :}

// checked
TemplateIdentifier :=
	identifier;

// checked
TemplateParameterList :=
	TemplateParameter;
	| TemplateParameter comma;
		{: ret = buildTreeWithLoc(termTemplateParameterList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| TemplateParameter comma TemplateParameterList;
		{: ret = buildTreeWithLoc(termTemplateParameterList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateParameter :=
	TemplateTypeParameter;
	| TemplateValueParameter;
	| TemplateAliasParameter;
	| TemplateTupleParameter;
	| TemplateThisParameter;

// checked
TemplateTupleParameter :=
	identifier dotdotdot;
		{: ret = buildTreeWithLoc(termTemplateTupleParameter, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

//IdentifierOrTemplateInstance :=
//	identifier;
//	| TemplateInstance;

// checked
TemplateInstance :=
	TemplateIdentifier bang lparen TemplateArgumentList rparen;
		{: ret = buildTreeWithLoc(termTemplateInstance, [-5,-2], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| TemplateIdentifier bang TemplateSingleArgument;
		{: ret = buildTreeWithLoc(termTemplateInstance, [-3,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}

// checked
TemplateThisParameter :=
    this TemplateTypeParameter;
		{: ret = buildTreeWithLoc(termTemplateThisParameter, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateArgumentList :=
	TemplateArgument;
	| TemplateArgument comma;
		{: ret = buildTreeWithLoc(termTemplateArgumentList, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| TemplateArgument comma TemplateArgumentList;
		{: ret = buildTreeWithLoc(termTemplateArgumentList, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateArgument :=
	Type;
	| AssignExpression;
	| Symbol;

// checked
Symbol :=
	SymbolTail;
	| dot SymbolTail;
		{: ret = buildTreeWithLoc(termSymbol, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
SymbolTail :=
	identifier;
	| identifier dot SymbolTail;
		{: ret = buildTreeWithLoc(termSymbolTail, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| TemplateInstance;
	| TemplateInstance dot SymbolTail;
		{: ret = buildTreeWithLoc(termSymbolTail, [-3,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateSingleArgument :=
	identifier;
	| BasicTypeX;
	| charliteral;
	| stringliteral;
	| integer;
	| floatliteral;
	| true;
	| false;
	| null;
	| file;
	| line;

// checked
TemplateTypeParameter :=
	identifier;
	| identifier TemplateTypeParameterSpecialization;
		{: ret = buildTreeWithLoc(termTemplateTypeParameter, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| identifier TemplateTypeParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateTypeParameter, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| identifier TemplateTypeParameterSpecialization TemplateTypeParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateTypeParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
TemplateTypeParameterSpecialization :=
	colon Type;
		{: ret = buildTreeWithLoc(termTemplateTypeParameterSpecialization, 
			[-2,-1], actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateTypeParameterDefault :=
	assign Type;
		{: ret = buildTreeWithLoc(termTemplateTypeParameterDefault, 
			[-2,-1], actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateValueParameter :=
    BasicType Declarator;
		{: ret = buildTreeWithLoc(termTemplateValueParameter, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
    | BasicType Declarator TemplateValueParameterSpecialization;
		{: ret = buildTreeWithLoc(termTemplateValueParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
    | BasicType Declarator TemplateValueParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateValueParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}
    | BasicType Declarator TemplateValueParameterSpecialization TemplateValueParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateValueParameter, [-4,-3,-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
TemplateValueParameterSpecialization :=
    colon ConditionalExpression;
		{: ret = buildTreeWithLoc(termTemplateValueParameterSpecialization, 
			[-2,-1], actionNum, this.tokenStack[-2].getLoc()); :}

// already part of conditionalexpression
// checked
TemplateValueParameterDefault :=
	assign file;
		{: ret = buildTreeWithLoc(termTemplateValueParameterDefault, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| assign line;
		{: ret = buildTreeWithLoc(termTemplateValueParameterDefault, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| assign AssignExpression;
		{: ret = buildTreeWithLoc(termTemplateValueParameterDefault, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateAliasParameter :=
	alias BasicType Declarator TemplateAliasParameterSpecialization TemplateAliasParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-4,-3,-2,-1], 
			actionNum, this.tokenStack[-5].getLoc()); :}
	| alias identifier TemplateAliasParameterSpecialization TemplateAliasParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias identifier TemplateAliasParameterSpecialization;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias identifier TemplateAliasParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias identifier;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias BasicType Declarator TemplateAliasParameterDefault;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias BasicType Declarator TemplateAliasParameterSpecialization;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-3,-2,-1], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| alias BasicType Declarator;
		{: ret = buildTreeWithLoc(termTemplateAliasParameter, [-2,-1], 
			actionNum, this.tokenStack[-3].getLoc()); :}

// checked
TemplateAliasParameterSpecialization :=
	colon Type;
		{: ret = buildTreeWithLoc(termTemplateAliasParameterSpecialization, 
			[-1] , actionNum, this.tokenStack[-2].getLoc()); :}
	| colon ConditionalExpression;
		{: ret = buildTreeWithLoc(termTemplateAliasParameterSpecialization, 
			[-1] , actionNum, this.tokenStack[-2].getLoc()); :}

// checked
TemplateAliasParameterDefault :=
	assign Type;
		{: ret = buildTreeWithLoc(termTemplateAliasParameterDefault, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}
	| assign ConditionalExpression;
		{: ret = buildTreeWithLoc(termTemplateAliasParameterDefault, [-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
ClassTemplateDeclaration :=
	class identifier lparen TemplateParameterList rparen Constraint BaseClassList ClassBody;
		{: ret = buildTreeWithLoc(termClassTemplateDeclaration, 
			[-7,-5,-3,-2,-1], actionNum, this.tokenStack[-8].getLoc()); :}
	| class identifier lparen TemplateParameterList rparen BaseClassList ClassBody;
		{: ret = buildTreeWithLoc(termClassTemplateDeclaration, [-6,-4,-2,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
	| class identifier lparen TemplateParameterList rparen Constraint ClassBody;
		{: ret = buildTreeWithLoc(termClassTemplateDeclaration, [-6,-4,-2,-1], 
			actionNum, this.tokenStack[-7].getLoc()); :}
	| class identifier lparen TemplateParameterList rparen ClassBody;
		{: ret = buildTreeWithLoc(termClassTemplateDeclaration, [-5,-3,-1], 
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
StructTemplateDeclaration :=
	struct identifier lparen TemplateParameterList rparen Constraint StructBody;
		{: ret = buildTreeWithLoc(termStructTemplateDeclaration, [-6,-4,-2,-1],
			actionNum, this.tokenStack[-7].getLoc()); :}
	| struct identifier lparen TemplateParameterList rparen StructBody;
		{: ret = buildTreeWithLoc(termStructTemplateDeclaration, [-5,-3,-1],
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
UnionTemplateDeclaration :=
	union identifier lparen TemplateParameterList rparen Constraint StructBody;
		{: ret = buildTreeWithLoc(termUnionTemplateDeclaration, [-6,-4,-2,-1],
			actionNum, this.tokenStack[-7].getLoc()); :}
	| union identifier lparen TemplateParameterList rparen StructBody;
		{: ret = buildTreeWithLoc(termUnionTemplateDeclaration, [-5,-3,-1],
			actionNum, this.tokenStack[-6].getLoc()); :}

// checked
InterfaceTemplateDeclaration :=
	interface identifier lparen TemplateParameterList rparen Constraint BaseInterfaceList InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceTemplateDeclaration, 
			[-7,-5,-3,-2,-1], actionNum, this.tokenStack[-8].getLoc()); :}
	| interface identifier lparen TemplateParameterList rparen Constraint InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceTemplateDeclaration, 
			[-6,-4,-2,-1], actionNum, this.tokenStack[-7].getLoc()); :}
	| interface identifier lparen TemplateParameterList rparen InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceTemplateDeclaration, 
			[-5,-3,-1], actionNum, this.tokenStack[-7].getLoc()); :}
	| interface identifier lparen TemplateParameterList rparen BaseInterfaceList InterfaceBody;
		{: ret = buildTreeWithLoc(termInterfaceTemplateDeclaration, 
			[-6,-4,-2,-1], actionNum, this.tokenStack[-7].getLoc()); :}

// checked
TemplateMixinDeclaration :=
	mixin template TemplateIdentifier lparen TemplateParameterList rparen Constraint lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termTemplateMixinDeclaration,
			[-8,-6,-4,-2], actionNum, this.tokenStack[-10].getLoc()); :}
	| mixin template TemplateIdentifier lparen TemplateParameterList rparen lcurly DeclDefs rcurly;
		{: ret = buildTreeWithLoc(termTemplateMixinDeclaration, 
			[-7,-5,-2], actionNum, this.tokenStack[-9].getLoc()); :}

// checked
Constraint :=
	if lparen ConstraintExpression rparen;
		{: ret = buildTreeWithLoc(termConstraint, [-2], 
			actionNum, this.tokenStack[-4].getLoc()); :}

// checked
ConstraintExpression :=
	Expression;

// checked
TemplateMixin :=
	mixin TemplateIdentifier semicolon;
		{: ret = buildTreeWithLoc(termTemplateMixin, [-2], 
			actionNum, this.tokenStack[-3].getLoc()); :}
	| mixin TemplateIdentifier identifier semicolon;
		{: ret = buildTreeWithLoc(termTemplateMixin, [-3], 
			actionNum, this.tokenStack[-4].getLoc()); :}
	| mixin TemplateIdentifier bang lparen TemplateArgumentList rparen semicolon;
		{: ret = buildTreeWithLoc(termTemplateMixin, [-6,-3], 
			actionNum, this.tokenStack[-7].getLoc()); :}
	| mixin TemplateIdentifier bang lparen TemplateArgumentList rparen semicolon identifier;
		{: ret = buildTreeWithLoc(termTemplateMixin, [-7,-4,-1], 
			actionNum, this.tokenStack[-8].getLoc()); :}

// checked
UnitTest :=
	unittest FunctionBody;
		{: ret = buildTreeWithLoc(termUnitTest, [-2,-1], 
			actionNum, this.tokenStack[-2].getLoc()); :}

// checked
AsmInstruction :=
	stringliteral;
