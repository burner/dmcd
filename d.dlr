%left identifierIdenTemp

S := seatdModule;

seatdModule :=
	DeclDefsOpt;
	| ModuleKeyword ModuleName semicolon;
	| ModuleKeyword ModuleName semicolon DeclDefsOpt;

//ModuleDeclarationOpt :=
//	ModuleKeyword ModuleName semicolon;
//	| epsilon;

ModuleKeyword :=
	module;

ModuleName :=
	ModuleName dot identifier;
	| identifier;

DeclDefsOpt :=
	DeclDefsOpt DeclDef;
	DeclDef;

DeclDef :=
	ConditionalDeclaration;
	| DeclDefNoConditional;

DeclDefNoConditional :=
	AttributeSpecifier;
	| StaticAssert;
	| Declaration;
	| ImportDeclaration;
	| EnumDeclaration;
	| TemplateMixin;
	| TemplateDeclaration;
	| FunctionTemplateDeclaration;
	| ClassTemplateDeclaration;
	| InterfaceTemplateDeclaration;
	| StructTemplateDeclaration;
	| ClassDeclaration;
	| InterfaceDeclaration;
	| AggregateDeclaration;
	| Constructor;
	| Destructor;
	| Invariant;
	| UnitTest;
	| StaticConstructor;
	| StaticDestructor;
	| MixinDeclaration;
	| semicolon;
	| DebugSpecification;
	| VersionSpecification;

ConditionalDeclaration :=
	Condition colon;
	| Condition DeclarationBlock;
	| Condition DeclarationBlock else DeclarationBlock;

Condition :=
	VersionCondition;
	| DebugCondition;
	| StaticIfCondition;

VersionCondition :=
	version lparen integer rparen;
	| version lparen identifier rparen;

VersionSpecification :=
	version assign integer semicolon;
	| version assign identifier semicolon;

DebugCondition :=
	debug lparen integer rparen;
	| debug lparen identifier rparen;
	| debug;

DebugSpecification :=
	debug assign identifier semicolon;
	| debug assign integer semicolon;

StaticIfCondition :=
	static if lparen AssignExpression rparen;

StaticAssert :=
	static assert lparen AssignExpression comma AssignExpression rparen 
		semicolon;
	| static assert lparen AssignExpression rparen semicolon;

ImportDeclaration :=
	import ImportList semicolon;

ImportList :=
	Import comma ImportList;
	| Import ImportBindListOpt;
	| Import;

Import :=
	identifier assign ModuleName;
	| ModuleName;

ImportBindListOpt :=
	colon ImportBindList;

ImportBindList :=
	ImportBindList comma ImportBind;
	| ImportBind;

ImportBind :=
	identifier assign identifier;
	| identifier;

AttributeSpecifier :=
	Attributes colon DeclDefsOpt;
	Attributes colon;
	| Attributes DeclarationBlock;

Attributes :=
	Attributes Attribute;
	| Attribute;

Attribute :=
	StorageClassAttribute;
	| ProtectionAttribute;
	| LinkageAttribute;
	| AlignAttribute;
	| Pragma;

StorageClassAttribute :=
	synchronized;
	| deprecated;
	| static;
	| final;
	| override;
	| abstract;
	| const;
	| auto;
	| scope;

ProtectionAttribute :=
	private;
	| package;
	| protected;
	| public;
	| export;


LinkageAttribute :=
	extern lparen identifier rparen;
	| extern lparen identifier increment rparen;
	| extern;

AlignAttribute :=
	align lparen integer rparen;
	| align;

Pragma :=
	pragma lparen identifier comma Expression rparen;
	| pragma lparen identifier rparen;

FunctionBody :=
	InStatement OutStatement BodyStatement;
	| OutStatement InStatement BodyStatement;
	| InStatement BodyStatement;
	| OutStatement BodyStatement;
	| BodyStatement;

FunctionBodyOpt :=
	FunctionBody;
	| semicolon;

InStatement :=
	in BlockStatement;

OutStatement :=
	out lparen identifier rparen BlockStatement;
	| out BlockStatement;

BodyStatement :=
	body BlockStatement;
	| BlockStatement;

ClassDeclaration :=
	class identifier BaseClassListOpt ClassBody;
	class identifier ClassBody;

// had epsilon
BaseClassListOpt :=
	colon BaseClassList;

BaseClassList :=
	BaseClassList comma SuperClass;
	| SuperClass;

SuperClass :=
	ProtectionNT IdentifierList;
	| IdentifierList;

ProtectionNT :=
	private;
	| package;
	| public;
	| export;

ClassBody:=
	lcurly rcurly;
	| lcurly ClassBodyDeclarations rcurly;

ClassBodyDeclarations :=
	ClassBodyDeclarations ClassBodyDeclaration;
	| ClassBodyDeclaration;

ClassBodyDeclaration :=
	DeclDef;
	| ClassAllocator;
	| ClassDeallocator;

Constructor :=
	this Parameters FunctionBodyOpt;

Destructor :=
	tilde this lparen rparen FunctionBodyOpt;

StaticConstructor :=
	static this lparen rparen FunctionBody;

StaticDestructor :=
	static tilde this lparen rparen FunctionBody;

Invariant :=
	invariant BlockStatement;
	| invariant lparen rparen BlockStatement;

UnitTest :=
	unittest FunctionBody;

ClassAllocator :=
	new Parameters FunctionBody;

ClassDeallocator :=
	delete Parameters FunctionBody;

InterfaceDeclaration :=
	interface identifier SuperInterfaceListOpt InterfaceBody;
	interface identifier InterfaceBody;

SuperInterfaceListOpt :=
	colon SuperInterfaces;

SuperInterfaces :=
	SuperInterfaces comma SuperInterface;
	| SuperInterface;

SuperInterface :=
	ProtectionNT IdentifierList;
	| IdentifierList;

InterfaceBody :=
	lcurly DeclDefsOpt rcurly;
	lcurly rcurly;

AggregateDeclaration :=
	Tag IdentifierOpt StructBody;
	| Tag IdentifierOpt semicolon;

Tag :=
	struct;
	| union;

StructBody :=
	lcurly rcurly;
	| lcurly rcurly semicolon;
	| lcurly StructBodyDeclarations rcurly;
	| lcurly StructBodyDeclarations rcurly semicolon;

StructBodyDeclarations :=
	StructBodyDeclarations StructBodyDeclaration;
	| StructBodyDeclaration;

StructBodyDeclaration :=
	DeclDef;
	| StructAllocator;
	| StructDeallocator;

StructAllocator :=
	ClassAllocator;

StructDeallocator :=
	ClassDeallocator;

ConditionalStatement :=
	Condition Statement else Statement;
	| Condition Statement;

Statement :=
	NonEmptyStatement;
	| BlockStatement;

StatementList :=
	StatementList Statement;
	| Statement;

NoScopeNonEmptyStatement :=
	NonEmptyStatement;
	| BlockStatement;

NoScopeStatement :=
	NonEmptyStatement;
	| BlockStatement;

NonEmptyStatement :=
	DeclDefNoConditional;
	| NonEmptyNoDeclStatement;

NonEmptyNoDeclStatement :=
	LabeledStatement;
	| ExpressionStatement;
	| IfStatement;
	| ConditionalStatement;
	| WhileStatement;
	| DoStatement;
	| ForStatement;
	| ForeachStatement;
	| ForeachRangeStatement;
	| SwitchStatement;
	| CaseStatement;
	| DefaultStatement;
	| ContinueStatement;
	| BreakStatement;
	| ReturnStatement;
	| GotoStatement;
	| WithStatement;
	| SynchronizedStatement;
	| TryStatement;
	| ScopeGuardStatement;
	| ThrowStatement;
	| VolatileStatement;
	| AsmStatement;
	| PragmaStatement;

ScopeStatement :=
	NonEmptyStatement;
	| BlockStatement;

NoDeclScopeStatement :=
	NonEmptyNoDeclStatement;
	| BlockStatement;

LabeledStatement :=
	identifier colon NoScopeStatement;

BlockStatement :=
	lcurly rcurly;
	| lcurly StatementList rcurly;

ExpressionStatement :=
	Expression semicolon;

IfStatement :=
	if lparen IfCondition rparen ScopeStatement;
	| if lparen IfCondition rparen ScopeStatement else ScopeStatement;

IfCondition :=
	Expression;
	| auto identifier assign Expression;
	| BasicType Declarator assign Expression;

WhileStatement :=
	while lparen Expression rparen ScopeStatement;

DoStatement :=
	do ScopeStatement while lparen Expression rparen;

ForStatement :=
	for lparen NoScopeNonEmptyStatement ExpressionOpt semicolon ExpressionOpt 
		rparen ScopeStatement;
	for lparen NoScopeNonEmptyStatement semicolon ExpressionOpt 
		rparen ScopeStatement;
	for lparen NoScopeNonEmptyStatement ExpressionOpt semicolon rparen 
		ScopeStatement;

ForeachStatement :=
	Foreach lparen ForeachTypeList semicolon Expression rparen ScopeStatement;

Foreach :=
	foreach;
	| foreach_reverse;

ForeachTypeList :=
	ForeachTypeList comma ForeachType;
	| ForeachType;

ForeachType :=
	inout TypeNT identifier;
	| ref TypeNT identifier;
	| TypeNT identifier;
	| inout identifier;
	| ref identifier;
	| identifier;

ForeachRangeStatement :=
	Foreach lparen ForeachType semicolon AssignExpression dotdot 
		AssignExpression rparen ScopeStatement;

SwitchStatement :=
	switch lparen Expression rparen BlockStatement;

CaseStatement :=
	case Expression colon ;

DefaultStatement :=
	default colon;

ContinueStatement :=
	continue semicolon;
	| continue identifier semicolon;

BreakStatement :=
	break semicolon;
	| break identifier semicolon;

ReturnStatement :=
	return semicolon;
	| return Expression semicolon;

GotoStatement :=
	goto identifier semicolon;
	| goto default semicolon;
	| goto case semicolon;
	| goto case Expression semicolon;

WithStatement :=
	with lparen Expression rparen ScopeStatement;
	| with lparen TemplateInstance rparen ScopeStatement;

SynchronizedStatement :=
	synchronized NoDeclScopeStatement;
	| synchronized lparen Expression rparen ScopeStatement;

TryStatement :=
	try ScopeStatement Catches;
	| try ScopeStatement Catches FinallyStatement;
	| try ScopeStatement FinallyStatement;

Catches :=
	LastCatch;
	| Catch Catches;
	| Catch;

LastCatch :=
	catch NoScopeNonEmptyStatement;

Catch :=
	catch lparen Parameter rparen NoScopeNonEmptyStatement;

FinallyStatement :=
	finally NoScopeNonEmptyStatement;

ThrowStatement :=
	throw Expression semicolon;

ScopeGuardStatement :=
	scope lparen identifier rparen Statement;

VolatileStatement :=
	volatile Statement;
	| volatile semicolon;

//| asm lcurly AsmInstructionList rcurly;
AsmStatement :=
	asm lcurly rcurly;

//AsmInstructionList :=
//	AsmInstructionList AsmInstruction;
//	| AsmInstruction;
//
//AsmInstruction :=
//	epsilon;

PragmaStatement :=
	Pragma NoScopeStatement;

DeclarationBlock :=
	lcurly DeclDefsOpt rcurly;
	lcurly rcurly;
	| DeclDef;

MixinDeclaration :=
	mixin lparen Expression rparen semicolon;

Declaration :=
	TypedefAlias Declaration2;
	| TypedefAlias Attributes Declaration2;
	| TypedefAlias Attributes identifier assign AssignExpression semicolon;
	| Attributes Declaration2;
	| Attributes IdentifierSimpleInitializerList semicolon;
	| Declaration2;

TypedefAlias :=
	typedef;
	| alias;

Declaration2 :=
	BasicType Declarator FunctionBody;
	| BasicType Declarators semicolon;

IdentifierSimpleInitializerList :=
	IdentifierSimpleInitializerList comma identifier assign AssignExpression;
	| identifier assign AssignExpression;

Declarators :=
	DeclaratorInitializer;
	| DeclaratorInitializer comma IdentifierInitializerList;

DeclaratorInitializer :=
	Declarator;
	| Declarator assign Initializer;

IdentifierInitializerList :=
	IdentifierInitializerList comma IdentifierInitializer;
	| IdentifierInitializer;

IdentifierInitializer :=
	identifier;
	| identifier assign Initializer;

BasicType :=
	BasicTypeNoIdList;
	| dot IdentifierList;
	| IdentifierList;

BasicTypeNoIdList :=
	bool;
	| byte;
	| ubyte;
	| short;
	| ushort;
	| int;
	| uint;
	| long;
	| ulong;
	| char;
	| wchar;
	| dchar;
	| floatSym;
	| double;
	| real;
	| ifloat;
	| idouble;
	| ireal;
	| cfloat;
	| cdouble;
	| creal;
	| void;
	| Typeof;
	| Typeof IdentifierList; {: ret = this.basTypNoIdLsta(); :}
	| TypeConstructor lparen TypeNT rparen; {: ret = this.basTypNoIdLstb(); :}

BasicType2 :=
	tilde;
	| lbrack rbrack;
	| lbrack Expression rbrack;
	| lbrack TypeNT rbrack;
	| lbrack AssignExpression dotdot AssignExpression rbrack;
	| delegate Parameters;
	| function Parameters;

TypeConstructor :=
	const;
	| invariant;

Declarator :=
	BasicType2 DeclaratorOpt;
	| identifier DeclaratorSuffixesOpt;
	| lparen Declarator rparen DeclaratorSuffixesOpt;


// | epsilon; I Hope this is ok TODO
TemplateArgumentListOpt :=
	TemplateArgumentList;

TemplateArgumentList :=
	TemplateArgumentList comma TemplateArgument; 
		{: ret = this.tmpArgLstAst(); :}
	| TemplateArgument;

Declarator2 :=
	BasicType2;
	| BasicType2 Declarator2;
	| lparen Declarator2 rparen DeclaratorSuffixesOpt;

Parameters :=
	lparen rparen;
	| lparen ParameterList rparen;

ParameterListOpt :=
	ParameterList;
	| epsilon;

ParameterList :=
	Parameter;
	| Parameter comma ParameterList;
	| Parameter dotdotdot;
	| dotdotdot;

Parameter :=
	Parameter2;
	| InOut Parameter2;
	| ParameterStorageClasses Parameter2;
	| InOut ParameterStorageClasses Parameter2;

Parameter2 :=
	BasicType DeclaratorOpt;
	| BasicType DeclaratorOpt assign AssignExpression;

ParameterStorageClasses :=
	ParameterStorageClasses ParameterStorageClass;
	| ParameterStorageClass;

ParameterStorageClass :=
	const;
	| invariant;
	| final;
	| scope;
	| static;

InOut :=
	inout;
	| in;
	| out;
	| ref;
	| lazy;

Initializer :=
	void;
	| NonVoidInitializer;

NonVoidInitializer :=
	AssignExpression;
	| ArrayInitializer;
	| StructInitializer;

ArrayInitializer :=
	lbrack rbrack;
	| lbrack ArrayStructMemberInitializers rbrack;

StructInitializer :=
	lcurly rcurly;
	| lcurly ArrayStructMemberInitializers rcurly;

ArrayStructMemberInitializers :=
	ArrayStructMemberInitializers comma ArrayStructMemberInitializer;
	| ArrayStructMemberInitializers comma;
	| ArrayStructMemberInitializer;

ArrayStructMemberInitializer :=
	NonVoidInitializer;
	| identifier colon NonVoidInitializer;

EnumDeclaration :=
	enum identifier EnumBaseTypeOpt EnumBody;
	| enum EnumBaseTypeOpt EnumBody;

EnumBaseTypeOpt :=
	colon TypeNT;
	| epsilon;

EnumBody :=
	semicolon;
	| lcurly EnumMembers rcurly;

EnumMembers :=
	EnumMembers comma EnumMember;
	| EnumMembers comma;
	| EnumMember;

EnumMember :=
	identifier EnumInitializerOpt;

EnumInitializerOpt :=
	assign AssignExpression;
	| epsilon;

TemplateDeclaration :=
	template identifier lparen TemplateParameterListOpt rparen lcurly 
		DeclDefsOpt rcurly;


TemplateParameterListOpt :=
	TemplateParameterList;
	| epsilon;

TemplateParameterList :=
	TemplateParameterList comma TemplateParameter;
	| TemplateParameter;

TemplateParameter :=
	TemplateAliasParameter;
	| TemplateTupleParameter;
	| TemplateValueParameter;
	| TemplateTypeParameter;

TemplateTypeParameter :=
	identifier colon TypeNT;
	| identifier colon TypeNT assign TypeNT;
	| identifier;

//BasicType Declarator TemplateValueParameterSpecializationOpt TemplateValueParameterDefaultOpt;
TemplateValueParameter :=
	BasicType Declarator;
	| BasicType Declarator colon ConditionalExpression;
	| BasicType Declarator assign ConditionalExpression;
	| BasicType Declarator colon ConditionalExpression assign ConditionalExpression;

//TemplateValueParameterSpecializationOpt :=
//	colon ConditionalExpression;
//	| epsilon;
//
//TemplateValueParameterDefaultOpt :=
//	assign ConditionalExpression;
//	| epsilon;

//alias identifier TemplateAliasParameterSpecializationOpt 
//TemplateAliasParameterDefaultOpt;
TemplateAliasParameter :=
	alias identifier colon TypeNT assign TypeNT; 
	| alias identifier assign TypeNT; 
	| alias identifier colon TypeNT; 
	| alias identifier; 

//TemplateAliasParameterSpecializationOpt :=
//	colon TypeNT;
//	| epsilon;
//
//TemplateAliasParameterDefaultOpt :=
//	assign TypeNT;
//	| epsilon;

TemplateTupleParameter :=
	identifier dotdotdot;

ClassTemplateDeclaration :=
	class identifier lparen TemplateParameterListOpt rparen BaseClassListOpt 
		ClassBody;

InterfaceTemplateDeclaration :=
	interface identifier lparen TemplateParameterListOpt rparen 
		SuperInterfaceListOpt InterfaceBody;

StructTemplateDeclaration :=
	struct identifier lparen TemplateParameterListOpt rparen StructBody;

FunctionTemplateDeclaration :=
	TypeIdent lparen TemplateParameterList rparen lparen ParameterListOpt 
		rparen FunctionBody;

TypeIdent :=
	BasicType identifier;
	| TypeNT identifier;

TemplateInstance :=
	identifier bang lparen TemplateArgumentList rparen;
		{: ret = this.tmpInsAst(); :}
	| identifier bang lparen rparen;

TemplateArgument :=
	TypeNT;
	| AssignExpression;
	| identifier;

TemplateMixin :=
	mixin identifier TemplateMixin2 IdentifierOpt semicolon;
	mixin identifier IdentifierOpt semicolon;

TemplateMixin2 :=
	bang lparen TemplateArgumentListOpt rparen;
	bang lparen rparen;

Expression :=
	AssignExpression;
	| Expression comma AssignExpression; {: ret = exprExprAst(); :}

// had epsilon;
ExpressionOpt :=
	Expression;

AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression plusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression minusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression multassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression divassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression modassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression andassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression orassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression notequal AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression tildeassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression leftshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression rightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorxorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}

ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = this.condExprAst(); :}

OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicor AndAndExpression; {: ret = this.orOrExprAst(); :}

AndAndExpression :=
	OrExpression;
	| AndAndExpression logicand OrExpression; {: ret = this.andAndExprAst(); :}

OrExpression :=
	XorExpression;
	| OrExpression or XorExpression; {: ret = this.orExprAst(); :}

XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression; {: ret = this.xorExprAst(); :}

AndExpression :=
	CmpExpression;
	| AndExpression and CmpExpression; {: ret = this.andExprAst(); :}

CmpExpression :=
	ShiftExpression;
	| ShiftExpression equal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression notequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression is ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression bangis ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression less ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression lessequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greater ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquare ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression square ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression squareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreater ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmaller ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmallerequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression in ShiftExpression; {: ret = this.cmpExprAst(); :}

IsNotIs :=
	is;
	| bangis;

ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression rightshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression unsignedrightshift AddExpression; 
		{: ret = this.shiExprAst(); :}

AddExpression :=
	MulExpression;
	| AddExpression plus MulExpression; {: ret = this.addExprAst(); :}
	| AddExpression minus MulExpression; {: ret = this.addExprAst(); :}
	| CatExpression;

CatExpression :=
	AddExpression tilde MulExpression;

MulExpression :=
	UnaryExpression;
	| MulExpression star UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression div UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression modulo UnaryExpression; {: ret = this.mulExprAst(); :}

UnaryExpression :=
	PostfixExpression;
	| and UnaryExpression; {: ret = this.unExprAst(); :}
	| bang UnaryExpression; {: ret = this.unExprAst(); :}
	| decrement UnaryExpression; {: ret = this.unExprAst(); :}
	| increment UnaryExpression; {: ret = this.unExprAst(); :}
	| minus UnaryExpression; {: ret = this.unExprAst(); :}
	| plus UnaryExpression; {: ret = this.unExprAst(); :}
	| star UnaryExpression; {: ret = this.unExprAst(); :}
	| tilde UnaryExpression; {: ret = this.unExprAst(); :}
	| lparen TypeNT rparen dot identifier;
	| NewExpression;
	| delete UnaryExpression;
	| cast lparen TypeNT rparen UnaryExpression;

PostfixExpression :=
	dollarsym; {: ret = this.posExprAst(); :}
	| false; {: ret = this.posExprAst(); :}
	| float; {: ret = this.posExprAst(); :}
	| integer; {: ret = this.posExprAst(); :}
	| null;  {: ret = this.posExprAst(); :}
	| true; {: ret = this.posExprAst(); :}
	| AssertExpression;
	| MixinExpression;
	| IsExpression;
	| PostfixExpression2;

PostfixExpression2 :=
	PrimaryExpression;
	| PostfixExpression2 dot identifier;
	| PostfixExpression2 dot TemplateInstance;
	| PostfixExpression2 increment;
	| PostfixExpression2 decrement;
	| PostfixExpression2 lparen ArgumentList rparen;
	| PostfixExpression2 lparen rparen;
	| PostfixExpression2 lbrack ArgumentList rbrack;
	| PostfixExpression2 lbrack rbrack;
	| PostfixExpression2 lbrack AssignExpression dotdot AssignExpression 
		rbrack;

PrimaryExpression :=
	identifier;
	| dot identifier;
	| TemplateInstance;
	| dot TemplateInstance;
	| this;
	| super;
	| characterliteral;
	| StringLiterals;
	| ArrayLiteral;
	| AssocArrayLiteral;
	| FunctionLiteral;
	| ImportExpression;
	| BasicTypeNoIdList dot identifier;
	| typeid lparen TypeNT rparen;
	| lparen Expression rparen;
	| TraitsExpression;

AssertExpression :=
	assert lparen AssignExpression rparen;
	| assert lparen AssignExpression comma AssignExpression rparen;

MixinExpression :=
	mixin lparen AssignExpression rparen;

ImportExpression :=
	import lparen AssignExpression rparen;

IsExpression :=
	IsNotIs lparen TypeNT rparen; 
		{: ret = this.isExprAstA(); :}
	| IsNotIs lparen TypeNT colon TypeSpecialization rparen; 
		{: ret = this.isExprAstB(); :}
	| IsNotIs lparen TypeNT equal TypeSpecialization rparen; 
		{: ret = this.isExprAstB(); :}
	| IsNotIs lparen TypeNT identifier rparen;
		{: ret = this.isExprAstC(); :}
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization rparen;
		{: ret = this.isExprAstD(); :}
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization rparen;
		{: ret = this.isExprAstD(); :}
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization comma TemplateParameterList rparen;
		{: ret = this.isExprAstE(); :}
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization comma TemplateParameterList rparen;
		{: ret = this.isExprAstE(); :}

TypeSpecialization :=
	TypeNT;
	| typedef;
	| struct;
	| union;
	| class;
	| interface;
	| enum;
	| function;
	| delegate;
	| super;
	| return;

StringLiterals :=
	astring;
	| StringLiterals astring;

ArrayLiteral :=
	lbrack ArgumentList rbrack;
	| lbrack rbrack;

AssocArrayLiteral :=
	lbrack KeyValuePairs rbrack;

KeyValuePairs:=
	KeyValuePair;
	| KeyValuePair comma KeyValuePairs;

KeyValuePair :=
	ConditionalExpression colon ConditionalExpression;

FunctionLiteral :=
	function TypeOpt lparen ParameterListOpt rparen FunctionBody;
	| delegate TypeOpt lparen ParameterListOpt rparen FunctionBody;
	| function TypeOpt FunctionBody;
	| delegate TypeOpt FunctionBody;
	| lparen ParameterListOpt rparen FunctionBody;
	| FunctionBody;

NewExpression :=
	NewArguments TypeNT lbrack AssignExpression rbrack;
	| NewArguments TypeNT lparen ArgumentList rparen;
	| NewArguments TypeNT lparen rparen;
	| NewArguments TypeNT;
	| NewArguments ClassArguments BaseClassListOpt lcurly DeclDefsOpt rcurly;

NewArguments :=
	new lparen ArgumentList rparen;
	new lparen rparen;
	| new;

ClassArguments :=
	class lparen ArgumentList rparen;
	class lparen rparen;
	| class;

// hat an epsilon;
ArgumentList :=
	Expression;

TraitsExpression :=
	__traits lparen identifier comma TraitsArguments rparen;

TraitsArguments :=
	TraitsArguments comma TraitsArgument;
	| TraitsArgument;

TraitsArgument :=
	AssignExpression;
	| TypeNT;

IdentifierOpt :=
	identifier;
	| epsilon;
