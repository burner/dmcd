S := Expression;

Expression :=
	AssignExpression;
	| Expression comma AssignExpression; {: ret = exprExprAst(); :}

ExpressionOpt :=
	Expression;
	| epsilon;

AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression; {: ret = assiExprAst(); :}
	| ConditionalExpression plusassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression minusassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression multassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression divassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression modassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression andassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression orassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression xorassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression notequal AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression tildeassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression leftshiftassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression rightshiftassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression; 
		{: ret = assiExprAst(); :}
	| ConditionalExpression xorxorassign AssignExpression; 
		{: ret = assiExprAst(); :}

ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = this.condExprAst(); :}

OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicor AndAndExpression; {: ret = this.orOrExprAst(); :}

AndAndExpression :=
	OrExpression;
	| AndAndExpression logicand OrExpression; {: ret = this.andAndExprAst(); :}

OrExpression :=
	XorExpression;
	| OrExpression or XorExpression; {: ret = this.orExprAst(); :}

XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression; {: ret = this.xorExprAst(); :}

AndExpression :=
	CmpExpression;
	| AndExpression and CmpExpression; {: ret = this.andExprAst(); :}

CmpExpression :=
	ShiftExpression;
	| ShiftExpression equal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression notequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression is ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression bangis ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression less ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression lessequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greater ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquare ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression square ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression squareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreater ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmaller ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmallerequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression in ShiftExpression; {: ret = this.cmpExprAst(); :}

IsNotIs :=
	is;
	| bangis;

ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression rightshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression unsignedrightshift AddExpression; 
		{: ret = this.shiExprAst(); :}

AddExpression :=
	MulExpression;
	| AddExpression plus MulExpression; {: ret = this.addExprAst(); :}
	| AddExpression minus MulExpression; {: ret = this.addExprAst(); :}

MulExpression :=
	UnaryExpression;
	| MulExpression star UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression div UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression modulo UnaryExpression; {: ret = this.mulExprAst(); :}

UnaryExpression :=
	PostfixExpression;
	| and UnaryExpression; {: ret = this.unExprAst(); :}
	| bang UnaryExpression; {: ret = this.unExprAst(); :}
	| decrement UnaryExpression; {: ret = this.unExprAst(); :}
	| increment UnaryExpression; {: ret = this.unExprAst(); :}
	| minus UnaryExpression; {: ret = this.unExprAst(); :}
	| plus UnaryExpression; {: ret = this.unExprAst(); :}
	| star UnaryExpression; {: ret = this.unExprAst(); :}
	| tilde UnaryExpression; {: ret = this.unExprAst(); :}

PostfixExpression :=
	dollarsym; {: ret = this.posExprAst(); :}
	| false; {: ret = this.posExprAst(); :}
	| float; {: ret = this.posExprAst(); :}
	| integer; {: ret = this.posExprAst(); :}
	| null;  {: ret = this.posExprAst(); :}
	| true; {: ret = this.posExprAst(); :}
	| AssertExpression;
	| IsExpression;
	| MixinExpression;

AssertExpression :=
	assert lparen AssignExpression rparen; {: ret = this.asseExprAst1(); :}
	| assert lparen AssignExpression comma AssignExpression rparen;
		{: ret = this.asseExprAst2(); :}

MixinExpression :=
	mixin lparen AssignExpression rparen; {: ret = this.mixExprAst(); :}

ImportExpression :=
	import lparen AssignExpression rparen; {: ret = this.impExprAst(); :}

IsExpression :=
	IsNotIs lparen TypeNT rparen;
	| IsNotIs lparen TypeNT colon TypeSpecialization rparen;
	| IsNotIs lparen TypeNT equal TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier rparen;
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization comma TemplateParameterList rparen;
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization comma TemplateParameterList rparen;

TypeSpecialization :=
	TypeNT;
	| typedef;
	| struct;
	| union;
	| class;
	| interface;
	| enum;
	| function;
	| delegate;
	| super;
	| return;

TypeNT :=
	BasicType;
	| BasicType Declarator2;

BasicType :=
	BasicTypeNoIdList;
	| dot IdentifierList;
	| IdentifierList;

Declarator2 :=
	BasicType2;
	| BasicType2 Declarator2;
	| lparen Declarator2 rparen DeclaratorSuffixesOpt;

BasicType2 :=
	tilde;
	| lbrack rbrack;
	| lbrack Expression rbrack;
	| lbrack TypeNT rbrack;
	| lbrack AssignExpression dotdot AssignExpression rbrack;
	// | delegate Parameters;
	// | function Parameters;

// some are missing here
IdentifierList := 
	identifier;
	| IdentifierList dot identifier;

DeclaratorSuffixesOpt :=
	DeclaratorSuffixesOpt DeclaratorSuffix;
	| epsilon;

// some are missing here
DeclaratorSuffix :=
	lbrack rbrack;
	| lbrack Expression rbrack;
	| lbrack TypeNT rbrack;
