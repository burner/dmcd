%left identifierIdenTemp

S := Declarator2;

Expression :=
	AssignExpression;
	| Expression comma AssignExpression; {: ret = exprExprAst(); :}

ExpressionOpt :=
	Expression;
	| epsilon;

AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression plusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression minusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression multassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression divassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression modassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression andassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression orassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression notequal AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression tildeassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression leftshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression rightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorxorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}

ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = this.condExprAst(); :}

OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicor AndAndExpression; {: ret = this.orOrExprAst(); :}

AndAndExpression :=
	OrExpression;
	| AndAndExpression logicand OrExpression; {: ret = this.andAndExprAst(); :}

OrExpression :=
	XorExpression;
	| OrExpression or XorExpression; {: ret = this.orExprAst(); :}

XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression; {: ret = this.xorExprAst(); :}

AndExpression :=
	CmpExpression;
	| AndExpression and CmpExpression; {: ret = this.andExprAst(); :}

CmpExpression :=
	ShiftExpression;
	| ShiftExpression equal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression notequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression is ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression bangis ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression less ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression lessequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greater ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquare ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression square ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression squareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreater ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmaller ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmallerequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression in ShiftExpression; {: ret = this.cmpExprAst(); :}

IsNotIs :=
	is;
	| bangis;

ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression rightshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression unsignedrightshift AddExpression; 
		{: ret = this.shiExprAst(); :}

AddExpression :=
	MulExpression;
	| AddExpression plus MulExpression; {: ret = this.addExprAst(); :}
	| AddExpression minus MulExpression; {: ret = this.addExprAst(); :}

MulExpression :=
	UnaryExpression;
	| MulExpression star UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression div UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression modulo UnaryExpression; {: ret = this.mulExprAst(); :}

UnaryExpression :=
	PostfixExpression;
	| and UnaryExpression; {: ret = this.unExprAst(); :}
	| bang UnaryExpression; {: ret = this.unExprAst(); :}
	| decrement UnaryExpression; {: ret = this.unExprAst(); :}
	| increment UnaryExpression; {: ret = this.unExprAst(); :}
	| minus UnaryExpression; {: ret = this.unExprAst(); :}
	| plus UnaryExpression; {: ret = this.unExprAst(); :}
	| star UnaryExpression; {: ret = this.unExprAst(); :}
	| tilde UnaryExpression; {: ret = this.unExprAst(); :}

PostfixExpression :=
	dollarsym; {: ret = this.posExprAst(); :}
	| false; {: ret = this.posExprAst(); :}
	| float; {: ret = this.posExprAst(); :}
	| integer; {: ret = this.posExprAst(); :}
	| null;  {: ret = this.posExprAst(); :}
	| true; {: ret = this.posExprAst(); :}
	| AssertExpression;
	| IsExpression;
	| MixinExpression;

AssertExpression :=
	assert lparen AssignExpression rparen; {: ret = this.asseExprAst1(); :}
	| assert lparen AssignExpression comma AssignExpression rparen;
		{: ret = this.asseExprAst2(); :}

MixinExpression :=
	mixin lparen AssignExpression rparen; {: ret = this.mixExprAst(); :}

ImportExpression :=
	import lparen AssignExpression rparen; {: ret = this.impExprAst(); :}

IsExpression :=
	IsNotIs lparen TypeNT rparen;
	| IsNotIs lparen TypeNT colon TypeSpecialization rparen;
	| IsNotIs lparen TypeNT equal TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier rparen;
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization rparen;
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization comma TemplateParameterList rparen;
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization comma TemplateParameterList rparen;

TypeSpecialization :=
	TypeNT;
	| typedef;
	| struct;
	| union;
	| class;
	| interface;
	| enum;
	| function;
	| delegate;
	| super;
	| return;

Typeof :=
	typeof lparen Expression rparen; {: ret = this.typOfAst(); :}

TypeNT :=
	BasicType;
	| BasicType Declarator2; {: ret = this.typNTAst(); :}

BasicType :=
	BasicTypeNoIdList;
	| dot IdentifierList; {: ret = this.basTypAst(); :}
	| IdentifierList;

Declarator2 :=
	BasicType2;
	| BasicType2 Declarator2; {: ret = this.dec2aAst(); :}
	//| lparen Declarator2 rparen DeclaratorSuffixesOpt; Check this TODO
	| lparen Declarator2 rparen DeclaratorSuffixesOpt;
		{: ret = this.dec2bAst(); :}
	| lparen Declarator2 rparen;
		{: ret = this.dec2cAst(); :}

BasicType2 :=
	tilde;
	| lbrack rbrack; 
		{: ret = Token(this.tokenStack[-2].getLoc(), termBasicType2); :}
	| lbrack Expression rbrack; {: ret = this.basTyp2a(); :}
	| lbrack TypeNT rbrack; {: ret = this.basTyp2a(); :}
	| lbrack AssignExpression dotdot AssignExpression rbrack;
		{: ret = this.basTyp2b(); :}
	// | delegate Parameters;
	// | function Parameters;

// some are missing here
IdentifierList := 
	identifier %prec identifierIdenTemp;
	| IdentifierList dot identifier; {: ret = idLstAst(); :}
	| IdentifierList dot TemplateInstance; {: ret = idLstAst(); :}

DeclaratorSuffixesOpt :=
	DeclaratorSuffixesOpt DeclaratorSuffix; {: ret = decSufOpaAst(); :}
	| DeclaratorSuffix; {: ret = decSufOpbAst(); :}
	//| epsilon; TODO check this

// some are missing here
DeclaratorSuffix :=
	lbrack rbrack; 
		{: ret = Token(this.tokenStack[-2].getLoc(), termDeclaratorSuffix); :}
	| lbrack Expression rbrack; {: ret = this.tokenStack[-2]; :}
	| lbrack TypeNT rbrack; {: ret = this.tokenStack[-2]; :}

BasicTypeNoIdList :=
	bool;
	| byte;
	| ubyte;
	| short;
	| ushort;
	| int;
	| uint;
	| long;
	| ulong;
	| char;
	| wchar;
	| dchar;
	| floatSym;
	| double;
	| real;
	| ifloat;
	| idouble;
	| ireal;
	| cfloat;
	| cdouble;
	| creal;
	| void;
	| Typeof;
	| Typeof IdentifierList; {: ret = this.basTypNoIdLsta(); :}
	| TypeConstructor lparen TypeNT rparen; {: ret = this.basTypNoIdLstb(); :}

TemplateInstance :=
	identifier bang lparen TemplateArgumentListOpt rparen;
		{: ret = this.tmpInsAst(); :}
	| identifier bang lparen rparen;

TemplateArgumentListOpt :=
	TemplateArgumentList;
	// | epsilon; I Hope this is ok TODO

TemplateArgumentList :=
	TemplateArgumentList comma TemplateArgument; 
		{: ret = this.tmpArgLstAst(); :}
	| TemplateArgument;

TemplateArgument :=
	TypeNT;
	| AssignExpression;
	| identifier;
