%left identifierIdenTemp

S := seatdModule;

seatdModule :=
	DeclDefsOpt;
	| ModuleKeyword ModuleName semicolon;
	| ModuleKeyword ModuleName semicolon DeclDefsOpt;

//ModuleDeclarationOpt :=
//	ModuleKeyword ModuleName semicolon;
//	| epsilon;

ModuleKeyword :=
	module;

ModuleName :=
	ModuleName dot identifier;
	| identifier;

DeclDefsOpt :=
	DeclDefsOpt DeclDef;
	DeclDef;

DeclDef :=
	ConditionalDeclaration;
	| DeclDefNoConditional;

DeclDefNoConditional :=
	AttributeSpecifier;
	| StaticAssert;
	| Declaration;
	| ImportDeclaration;
	| EnumDeclaration;
	| TemplateMixin;
	| TemplateDeclaration;
	| FunctionTemplateDeclaration;
	| ClassTemplateDeclaration;
	| InterfaceTemplateDeclaration;
	| StructTemplateDeclaration;
	| ClassDeclaration;
	| InterfaceDeclaration;
	| AggregateDeclaration;
	| Constructor;
	| Destructor;
	| Invariant;
	| UnitTest;
	| StaticConstructor;
	| StaticDestructor;
	| MixinDeclaration;
	| semicolon;
	| DebugSpecification;
	| VersionSpecification;

ConditionalDeclaration :=
	Condition colon;
	| Condition DeclarationBlock;
	| Condition DeclarationBlock else DeclarationBlock;

Condition :=
	VersionCondition;
	| DebugCondition;
	| StaticIfCondition;

VersionCondition :=
	version lparen integer rparen;
	| version lparen identifier rparen;

VersionSpecification :=
	version assign integer semicolon;
	| version assign identifier semicolon;

DebugCondition :=
	debug lparen integer rparen;
	| debug lparen identifier rparen;
	| debug;

DebugSpecification :=
	debug assign identifier semicolon;
	| debug assign integer semicolon;

StaticIfCondition :=
	static if lparen AssignExpression rparen;

StaticAssert :=
	static assert lparen AssignExpression comma AssignExpression rparen 
		semicolon;
	| static assert lparen AssignExpression rparen semicolon;

ImportDeclaration :=
	import ImportList semicolon;

ImportList :=
	Import comma ImportList;
	| Import ImportBindListOpt;
	| Import;

Import :=
	identifier assign ModuleName;
	| ModuleName;

ImportBindListOpt :=
	colon ImportBindList;
	| epsilon;

ImportBindList :=
	ImportBindList comma ImportBind;
	| ImportBind;

ImportBind :=
	identifier assign identifier;
	| identifier;

AttributeSpecifier :=
	Attributes colon DeclDefsOpt;
	| Attributes DeclarationBlock;

Attributes :=
	Attributes Attribute;
	| Attribute;

Attribute :=
	StorageClassAttribute;
	| ProtectionAttribute;
	| LinkageAttribute;
	| AlignAttribute;
	| Pragma;

StorageClassAttribute :=
	synchronized;
	| deprecated;
	| static;
	| final;
	| override;
	| abstract;
	| const;
	| auto;
	| scope;

ProtectionAttribute :=
	private;
	| package;
	| protected;
	| public;
	| export;


LinkageAttribute :=
	extern lparen identifier rparen;
	| extern lparen identifier increment rparen;
	| extern;

AlignAttribute :=
	align lparen integer rparen;
	| align;

Pragma :=
	pragma lparen identifier comma Expression rparen;
	| pragma lparen identifier rparen;

FunctionBody :=
	InStatement OutStatement BodyStatement;
	| OutStatement InStatement BodyStatement;
	| InStatement BodyStatement;
	| OutStatement BodyStatement;
	| BodyStatement;

FunctionBodyOpt :=
	FunctionBody;
	| semicolon;

InStatement :=
	in BlockStatement;

OutStatement :=
	out lparen identifier rparen BlockStatement;
	| out BlockStatement;

BodyStatement :=
	body BlockStatement;
	| BlockStatement;

ClassDeclaration :=
	class identifier BaseClassListOpt ClassBody;

BaseClassListOpt :=
	colon BaseClassList;
	| epsilon;

BaseClassList :=
	BaseClassList comma SuperClass;
	| SuperClass;

SuperClass :=
	ProtectionNT IdentifierList;
	| IdentifierList;

ProtectionNT :=
	private;
	| package;
	| public;
	| export;

ClassBody:=
	lcurly rcurly;
	| lcurly ClassBodyDeclarations rcurly;

ClassBodyDeclarations :=
	ClassBodyDeclarations ClassBodyDeclaration;
	| ClassBodyDeclaration;

ClassBodyDeclaration :=
	DeclDef;
	| ClassAllocator;
	| ClassDeallocator;

Constructor :=
	this Parameters FunctionBodyOpt;

Destructor :=
	tilde this lparen rparen FunctionBodyOpt;

StaticConstructor :=
	static this lparen rparen FunctionBody;

StaticDestructor :=
	static tilde this lparen rparen FunctionBody;

Invariant :=
	invariant BlockStatement;
	| invariant lparen rparen BlockStatement;

UnitTest :=
	unittest FunctionBody;

ClassAllocator :=
	new Parameters FunctionBody;

ClassDeallocator :=
	delete Parameters FunctionBody;

InterfaceDeclaration :=
	interface identifier SuperInterfaceListOpt InterfaceBody;

SuperInterfaceListOpt :=
	colon SuperInterfaces;
	| epsilon;

SuperInterfaces :=
	SuperInterfaces comma SuperInterface;
	| SuperInterface;

SuperInterface :=
	ProtectionNT IdentifierList;
	| IdentifierList;

InterfaceBody :=
	lcurly DeclDefsOpt rcurly;

AggregateDeclaration :=
	Tag IdentifierOpt StructBody;
	| Tag IdentifierOpt semicolon;

Tag :=
	struct;
	| union;

StructBody :=
	lcurly rcurly;
	| lcurly rcurly semicolon;
	| lcurly StructBodyDeclarations rcurly;
	| lcurly StructBodyDeclarations rcurly semicolon;

StructBodyDeclarations :=
	StructBodyDeclarations StructBodyDeclaration;
	| StructBodyDeclaration;

StructBodyDeclaration :=
	DeclDef;
	| StructAllocator;
	| StructDeallocator;

StructAllocator :=
	ClassAllocator;

StructDeallocator :=
	ClassDeallocator;

ConditionalStatement :=
	Condition Statement else Statement;
	| Condition Statement;

Statement :=
	NonEmptyStatement;
	| BlockStatement;

StatementList :=
	StatementList Statement;
	| Statement;

NoScopeNonEmptyStatement :=
	NonEmptyStatement;
	| BlockStatement;

NoScopeStatement :=
	NonEmptyStatement;
	| BlockStatement;

NonEmptyStatement :=
	DeclDefNoConditional;
	| NonEmptyNoDeclStatement;

NonEmptyNoDeclStatement :=
	LabeledStatement;
	| ExpressionStatement;
	| IfStatement;
	| ConditionalStatement;
	| WhileStatement;
	| DoStatement;
	| ForStatement;
	| ForeachStatement;
	| ForeachRangeStatement;
	| SwitchStatement;
	| CaseStatement;
	| DefaultStatement;
	| ContinueStatement;
	| BreakStatement;
	| ReturnStatement;
	| GotoStatement;
	| WithStatement;
	| SynchronizedStatement;
	| TryStatement;
	| ScopeGuardStatement;
	| ThrowStatement;
	| VolatileStatement;
	| AsmStatement;
	| PragmaStatement;

ScopeStatement :=
	NonEmptyStatement;
	| BlockStatement;

NoDeclScopeStatement :=
	NonEmptyNoDeclStatement;
	| BlockStatement;

LabeledStatement :=
	identifier colon NoScopeStatement;

BlockStatement :=
	lcurly rcurly;
	| lcurly StatementList rcurly;

ExpressionStatement :=
	Expression semicolon;

IfStatement :=
	if lparen IfCondition rparen ScopeStatement;
	| if lparen IfCondition rparen ScopeStatement else ScopeStatement;

IfCondition :=
	Expression;
	| auto identifier assign Expression;
	| BasicType Declarator assign Expression;

WhileStatement :=
	while lparen Expression rparen ScopeStatement;

DoStatement :=
	do ScopeStatement while lparen Expression rparen;

ForStatement :=
	for lparen NoScopeNonEmptyStatement ExpressionOpt semicolon ExpressionOpt 
		rparen ScopeStatement;

ForeachStatement :=
	Foreach lparen ForeachTypeList semicolon Expression rparen ScopeStatement;

Foreach :=
	foreach;
	| foreach_reverse;

ForeachTypeList :=
	ForeachTypeList comma ForeachType;
	| ForeachType;

ForeachType :=
	inout TypeNT identifier;
	| ref TypeNT identifier;
	| TypeNT identifier;
	| inout identifier;
	| ref identifier;
	| identifier;

ForeachRangeStatement :=
	Foreach lparen ForeachType semicolon AssignExpression dotdot 
		AssignExpression rparen ScopeStatement;

SwitchStatement :=
	switch lparen Expression rparen BlockStatement;

CaseStatement :=
	case Expression colon ;

DefaultStatement :=
	default colon;

ContinueStatement :=
	continue semicolon;
	| continue identifier semicolon;

BreakStatement :=
	break semicolon;
	| break identifier semicolon;

ReturnStatement :=
	return semicolon;
	| return Expression semicolon;

GotoStatement :=
	goto identifier semicolon;
	| goto default semicolon;
	| goto case semicolon;
	| goto case Expression semicolon;

WithStatement :=
	with lparen Expression rparen ScopeStatement;
	| with lparen TemplateInstance rparen ScopeStatement;

SynchronizedStatement :=
	synchronized NoDeclScopeStatement;
	| synchronized lparen Expression rparen ScopeStatement;

TryStatement :=
	try ScopeStatement Catches;
	| try ScopeStatement Catches FinallyStatement;
	| try ScopeStatement FinallyStatement;

Catches :=
	LastCatch;
	| Catch Catches;
	| Catch;

LastCatch :=
	catch NoScopeNonEmptyStatement;

Catch :=
	catch lparen Parameter rparen NoScopeNonEmptyStatement;

FinallyStatement :=
	finally NoScopeNonEmptyStatement;

ThrowStatement :=
	throw Expression semicolon;

ScopeGuardStatement :=
	scope lparen identifier rparen Statement;

VolatileStatement :=
	volatile Statement;
	| volatile semicolon;

AsmStatement :=
	asm lcurly rcurly;
	| asm lcurly AsmInstructionList rcurly;

AsmInstructionList :=
	AsmInstructionList AsmInstruction;
	| AsmInstruction;

AsmInstruction :=
	epsilon;

PragmaStatement :=
	Pragma NoScopeStatement;

DeclarationBlock :=
	lcurly DeclDefsOpt rcurly;
	| DeclDef;

MixinDeclaration :=
	mixin lparen Expression rparen semicolon;

Declaration :=
	TypedefAlias Declaration2;
	| TypedefAlias Attributes Declaration2;
	| TypedefAlias Attributes identifier assign AssignExpression semicolon;
	| Attributes Declaration2;
	| Attributes IdentifierSimpleInitializerList semicolon;
	| Declaration2;

TypedefAlias :=
	typedef;
	| alias;

Declaration2 :=
	BasicType Declarator FunctionBody;
	| BasicType Declarators semicolon;

IdentifierSimpleInitializerList :=
	IdentifierSimpleInitializerList comma identifier assign AssignExpression;
	| identifier assign AssignExpression;

Declarators :=
	DeclaratorInitializer;
	| DeclaratorInitializer comma IdentifierInitializerList;

DeclaratorInitializer :=
	Declarator;
	| Declarator assign Initializer;

IdentifierInitializerList :=
	IdentifierInitializerList comma IdentifierInitializer;
	| IdentifierInitializer;

IdentifierInitializer :=
	identifier;
	| identifier assign Initializer;

BasicType :=
	BasicTypeNoIdList;
	| dot IdentifierList;
	| IdentifierList;

Expression :=
	AssignExpression;
	| Expression comma AssignExpression; {: ret = exprExprAst(); :}

ExpressionOpt :=
	Expression;
	| epsilon;

AssignExpression :=
	ConditionalExpression;
	| ConditionalExpression assign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression plusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression minusassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression multassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression divassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression modassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression andassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression orassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression notequal AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression tildeassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression leftshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression rightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression unsignedrightshiftassign AssignExpression; 
		{: ret = this.assiExprAst(); :}
	| ConditionalExpression xorxorassign AssignExpression; 
		{: ret = this.assiExprAst(); :}

ConditionalExpression :=
	OrOrExpression;
	| OrOrExpression questionmark Expression colon ConditionalExpression;
		{: ret = this.condExprAst(); :}

OrOrExpression :=
	AndAndExpression;
	| OrOrExpression logicor AndAndExpression; {: ret = this.orOrExprAst(); :}

AndAndExpression :=
	OrExpression;
	| AndAndExpression logicand OrExpression; {: ret = this.andAndExprAst(); :}

OrExpression :=
	XorExpression;
	| OrExpression or XorExpression; {: ret = this.orExprAst(); :}

XorExpression :=
	AndExpression;
	| XorExpression xor AndExpression; {: ret = this.xorExprAst(); :}

AndExpression :=
	CmpExpression;
	| AndExpression and CmpExpression; {: ret = this.andExprAst(); :}

CmpExpression :=
	ShiftExpression;
	| ShiftExpression equal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression notequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression is ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression bangis ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression less ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression lessequal ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greater ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression greaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsquare ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression square ShiftExpression; {: ret = this.cmpExprAst(); :}
	| ShiftExpression squareequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreater ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression banggreaterequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmaller ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression bangsmallerequal ShiftExpression; 
		{: ret = this.cmpExprAst(); :}
	| ShiftExpression in ShiftExpression; {: ret = this.cmpExprAst(); :}

IsNotIs :=
	is;
	| bangis;

ShiftExpression :=
	AddExpression;
	| ShiftExpression leftshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression rightshift AddExpression; {: ret = this.shiExprAst(); :}
	| ShiftExpression unsignedrightshift AddExpression; 
		{: ret = this.shiExprAst(); :}

AddExpression :=
	MulExpression;
	| AddExpression plus MulExpression; {: ret = this.addExprAst(); :}
	| AddExpression minus MulExpression; {: ret = this.addExprAst(); :}

MulExpression :=
	UnaryExpression;
	| MulExpression star UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression div UnaryExpression; {: ret = this.mulExprAst(); :}
	| MulExpression modulo UnaryExpression; {: ret = this.mulExprAst(); :}

UnaryExpression :=
	PostfixExpression;
	| and UnaryExpression; {: ret = this.unExprAst(); :}
	| bang UnaryExpression; {: ret = this.unExprAst(); :}
	| decrement UnaryExpression; {: ret = this.unExprAst(); :}
	| increment UnaryExpression; {: ret = this.unExprAst(); :}
	| minus UnaryExpression; {: ret = this.unExprAst(); :}
	| plus UnaryExpression; {: ret = this.unExprAst(); :}
	| star UnaryExpression; {: ret = this.unExprAst(); :}
	| tilde UnaryExpression; {: ret = this.unExprAst(); :}

PostfixExpression :=
	dollarsym; {: ret = this.posExprAst(); :}
	| false; {: ret = this.posExprAst(); :}
	| float; {: ret = this.posExprAst(); :}
	| integer; {: ret = this.posExprAst(); :}
	| null;  {: ret = this.posExprAst(); :}
	| true; {: ret = this.posExprAst(); :}
	| AssertExpression;
	| IsExpression;
	| MixinExpression;

AssertExpression :=
	assert lparen AssignExpression rparen; {: ret = this.asseExprAst1(); :}
	| assert lparen AssignExpression comma AssignExpression rparen;
		{: ret = this.asseExprAst2(); :}

MixinExpression :=
	mixin lparen AssignExpression rparen; {: ret = this.mixExprAst(); :}

ImportExpression :=
	import lparen AssignExpression rparen; {: ret = this.impExprAst(); :}

IsExpression :=
	IsNotIs lparen TypeNT rparen; 
		{: ret = this.isExprAstA(); :}
	| IsNotIs lparen TypeNT colon TypeSpecialization rparen; 
		{: ret = this.isExprAstB(); :}
	| IsNotIs lparen TypeNT equal TypeSpecialization rparen; 
		{: ret = this.isExprAstB(); :}
	| IsNotIs lparen TypeNT identifier rparen;
		{: ret = this.isExprAstC(); :}
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization rparen;
		{: ret = this.isExprAstD(); :}
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization rparen;
		{: ret = this.isExprAstD(); :}
	| IsNotIs lparen TypeNT identifier colon TypeSpecialization comma TemplateParameterList rparen;
		{: ret = this.isExprAstE(); :}
	| IsNotIs lparen TypeNT identifier equal TypeSpecialization comma TemplateParameterList rparen;
		{: ret = this.isExprAstE(); :}

TypeSpecialization :=
	TypeNT;
	| typedef;
	| struct;
	| union;
	| class;
	| interface;
	| enum;
	| function;
	| delegate;
	| super;
	| return;

Typeof :=
	typeof lparen Expression rparen; {: ret = this.typOfAst(); :}

TypeNT :=
	BasicType;
	| BasicType Declarator2; {: ret = this.typNTAst(); :}

BasicType :=
	BasicTypeNoIdList;
	| dot IdentifierList; {: ret = this.basTypAst(); :}
	| IdentifierList;

//| lparen Declarator2 rparen DeclaratorSuffixesOpt; Check this TODO
Declarator2 :=
	BasicType2;
	| BasicType2 Declarator2; {: ret = this.dec2aAst(); :}
	| lparen Declarator2 rparen DeclaratorSuffixesOpt;
		{: ret = this.dec2bAst(); :}
	| lparen Declarator2 rparen;
		{: ret = this.dec2cAst(); :}

BasicType2 :=
	tilde;
	| lbrack rbrack; 
		{: ret = Token(this.tokenStack[-2].getLoc(), termBasicType2); :}
	| lbrack Expression rbrack; {: ret = this.basTyp2a(); :}
	| lbrack TypeNT rbrack; {: ret = this.basTyp2a(); :}
	| lbrack AssignExpression dotdot AssignExpression rbrack;
		{: ret = this.basTyp2b(); :}
	| delegate Parameters;
	| function Parameters;

// some are missing here
IdentifierList := 
	identifier %prec identifierIdenTemp;
	| IdentifierList dot identifier; {: ret = idLstAst(); :}
	| IdentifierList dot TemplateInstance; {: ret = idLstAst(); :}

DeclaratorSuffixesOpt :=
	DeclaratorSuffixesOpt DeclaratorSuffix; {: ret = decSufOpaAst(); :}
	| DeclaratorSuffix; {: ret = decSufOpbAst(); :}
	//| epsilon; TODO check this

// some are missing here
DeclaratorSuffix :=
	lbrack rbrack; 
		{: ret = Token(this.tokenStack[-2].getLoc(), termDeclaratorSuffix); :}
	| lbrack Expression rbrack; {: ret = this.tokenStack[-2]; :}
	| lbrack TypeNT rbrack; {: ret = this.tokenStack[-2]; :}

BasicTypeNoIdList :=
	bool;
	| byte;
	| ubyte;
	| short;
	| ushort;
	| int;
	| uint;
	| long;
	| ulong;
	| char;
	| wchar;
	| dchar;
	| floatSym;
	| double;
	| real;
	| ifloat;
	| idouble;
	| ireal;
	| cfloat;
	| cdouble;
	| creal;
	| void;
	| Typeof;
	| Typeof IdentifierList; {: ret = this.basTypNoIdLsta(); :}
	| TypeConstructor lparen TypeNT rparen; {: ret = this.basTypNoIdLstb(); :}

TemplateInstance :=
	identifier bang lparen TemplateArgumentList rparen;
		{: ret = this.tmpInsAst(); :}
	| identifier bang lparen rparen;

// | epsilon; I Hope this is ok TODO
TemplateArgumentListOpt :=
	TemplateArgumentList;

TemplateArgumentList :=
	TemplateArgumentList comma TemplateArgument; 
		{: ret = this.tmpArgLstAst(); :}
	| TemplateArgument;

TemplateArgument :=
	TypeNT;
	| AssignExpression;
	| identifier;

TemplateParameterListOpt :=
	TemplateParameterList;
	| epsilon;

TemplateParameterList :=
	TemplateParameterList comma TemplateParameter;
	| TemplateParameter;

TemplateParameter :=
	TemplateAliasParameter;
	| TemplateTupleParameter;
	| TemplateValueParameter;
	| TemplateTypeParameter;

TemplateTypeParameter :=
	identifier colon TypeNT;
	| identifier colon TypeNT assign TypeNT;
	| identifier;

//BasicType Declarator TemplateValueParameterSpecializationOpt TemplateValueParameterDefaultOpt;
TemplateValueParameter :=
	BasicType Declarator;
	| BasicType Declarator colon ConditionalExpression;
	| BasicType Declarator assign ConditionalExpression;
	| BasicType Declarator colon ConditionalExpression assign ConditionalExpression;

//TemplateValueParameterSpecializationOpt :=
//	colon ConditionalExpression;
//	| epsilon;
//
//TemplateValueParameterDefaultOpt :=
//	assign ConditionalExpression;
//	| epsilon;

//alias identifier TemplateAliasParameterSpecializationOpt 
//TemplateAliasParameterDefaultOpt;
TemplateAliasParameter :=
	alias identifier colon TypeNT assign TypeNT; 
	| alias identifier assign TypeNT; 
	| alias identifier colon TypeNT; 
	| alias identifier; 

//TemplateAliasParameterSpecializationOpt :=
//	colon TypeNT;
//	| epsilon;
//
//TemplateAliasParameterDefaultOpt :=
//	assign TypeNT;
//	| epsilon;

TemplateTupleParameter :=
	identifier dotdotdot;

